<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (X11; U; Linux 2.2.16-3ext3 i686) [Netscape]">
   <meta name="Author" content="The Rasterman & Lightman">
   <title>Imlib 2 - Documentation.</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EF" vlink="#51188E" alink="#FFFF00">


<center>
<h1>
<img SRC="imlib2.gif" ALT="Imlib2" height=128 width=256></h1></center>

<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>What
is it?</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="img/blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#6a7a8a" NOSAVE>Imlib 2 is the successor
to Imlib. It is NOT a newer version - it is a completely new library. Imlib
2 can be installed alongside Imlib 1.x without any problems since they
are effectively different libraries - BUT they Have very similar functionality.
<p>Imlib 2 does the following:
<ul>
<li>
Load image files from disk in one of many formats</li>

<li>
Save images to disk in one of many formats</li>

<li>
Render image data onto other images</li>

<li>
Render images to an X-Windows drawable</li>

<li>
Produce pixmaps and pixmap masks of Images</li>

<li>
Apply filters to images</li>

<li>
Rotate images</li>

<li>
Accept RGBA Data for images</li>

<li>
Scale images</li>

<li>
Alpha blend Images on other images or drawables</li>

<li>
Apply color correction and modification tables and factors to images</li>

<li>
Render images onto images with color correction and modification tables</li>

<li>
Render truetype anti-aliased text</li>

<li>
Render truetype anti-aliased text at any angle</li>

<li>
Render anti-aliased lines</li>

<li>
Render rectangles</li>

<li>
Render linear multi-colored gradients</li>

<li>
Cache data intelligently for maximum performance</li>

<li>
Allocate colors automatically</li>

<li>
Allow full control over caching and color allocation</li>

<li>
Provide highly optimized MMX assembly for core routines</li>

<li>
Provide plug-in filter interface</li>

<li>
Provide on-the-fly runtime plug-in image loading and saving interface</li>

<li>
Fastest image compositing, rendering and manipulation library for X</li>
</ul>
If what you want isn't in the list above somewhere then likely Imlib 2
does not do it. If it does it it likely does it faster than any other library
you can find (this includes gdk-pixbuf, gdkrgb, etc.) primarily because
of highly optimized code and a smart subsystem that does the dirty work
for you and picks up the pieces for you so you can be lazy and let all
the optimizations for FOR you.
<p>Imlib 2 can run without a display, so it can be easily used for background
image processing for web sites or servers - it only requires the X libraries
to be installed - that is all - it does not require an XServer to run unless
you wish to display images.
<p>The interface is simple - once you get used to it, the functions do
exactly what they say they do.</td>

<td><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br> 
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>A
Simple Example</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="img/blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#6a7a8a" NOSAVE>The best way to start
is to show a simple example of an Imlib2 program. This one will load an
image of any format you have a loader installed for (all loaders are dynamic
code objects that Imlib2 will use and update automatically runtime - anyone
is free to write a loader. All that has to be done is for the object to
be dropped into the loaders directory with the others and all Imlib2 programs
will automatically be able to use it - without a restart).
<blockquote>
<pre><tt><font color="#660000">/* standard headers */
#include &lt;X11/Xlib.h&gt;
#include &lt;Imlib2.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* main program */
int main(int argc, char **argv)
{
  /* an image handle */
  Imlib_Image image;
  
  /* if we provided &lt; 2 arguments after the command - exit */
  if (argc != 3) exit(1);
  /* load the image */
  image = imlib_load_image(argv[1]);
  /* if the load was successful */
  if (image)
    {
      char *tmp;
      /* set the image we loaded as the current context image to work on */
      imlib_context_set_image(image);
      /* set the image format to be the format of the extension of our last */
      /* argument - i.e. .png = png, .tif = tiff etc. */
      tmp = strrchr(argv[2], '.');
      if(tmp)
         imlib_image_set_format(tmp + 1);
      /* save the image */
      imlib_save_image(argv[2]);
    }
}</font></tt></pre>
Now to compile this
<br>
<tt><font color="#000099">cc imlib2_convert.c -o imlib2_convert `imlib2-config --cflags` `imlib2-config --libs`</font></tt>
<br>
You now have a program that if used as follows:
<br>
<tt><font color="#000099">./imlib2_convert image1.jpg image2.png</font></tt>
<br>
will convert image1.jpg into a png called image2.png. It is that simple.</blockquote>
</td>

<td><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br> 
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>How
Image Loading Works</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="img/blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#6a7a8a" NOSAVE>It is probably a
good idea to discuss how Imlib2 actually loads an Image so the programmer
knows what is going on, how to take advantage of the optimizations already
there and to explain why things work as they do.
<br> 
<blockquote>
<h3>
Loading using imlib_load_image();</h3>
This is likely to be by far the most common way to load an image - when
you don't really care about the details of the loading process or why it
failed - all you care about is if you got a valid image handle.
<p>When you call this function Imlib2 attempts to find the file specified
as the parameter. This will involve Imlib2 first checking to see if that
file path already has been loaded and is in Imlib2's cache (a cache of
already decoded images in memory to save having to load and decode from
disk all the time). If there already is a copy in the cache (either already
active or speculatively cached from a previous load &amp; free) this copy
will have its handle returned instead of Imlib2 checking on disk (in some
circumstances this is not true - see later in this section to find out).
This means if your program blindly loads an Image, renders it, then frees
it - then soon afterwards loads the same image again, it will not be loaded
from disk at all, instead it will simply be re-referenced from the cache
- meaning the load will be almost instant. A great way to take full advantage
of this is to set the cache to some size you are happy with for the image
data being used by your application and then all rendering o an image follows
the pseudo code:
<pre><tt><font color="#006600">set cache to some amount (e.g. 4 Mb)
...
rendering loop ...
    load image
    render image
    free image
... continue loop</font></tt></pre>
This may normally sound silly - load image, render then free - EVERY time
we want to use it, BUT - it is actually the smartest way to use Imlib2
- since the caching will find the image for you in the cache - you do not
need to manage your own cache, or worry about filling up memory with image
data - only as much memory as you have set for the cache size will actually
ever be used to store image data - if you have lots of image data to work
with then increase the cache size for better performance, but this is the
only thing you need to worry about. you won't have problems of accidentally
forgetting to free images later since you free them immediately after use.
<p>Now what happens if the file changes on disk while it's in cache? By
default nothing. The file is ignored. This is an optimization (to avoid
hitting the disk to check if the file changed for every load if it's cached).
You can inform Imlib2 that you care about this by using the <tt><font color="#660000">imlib_image_set_changes_on_disk();
</font></tt><font color="#000000">call.
Do this whenever you load an Image that you expect will change on disk,
and the fact that it changes really matters. Remember this will marginally
reduce the caching performance.</font>
<p><font color="#000000">Now what actually happens when we try and load
an image using a filename? First the filename is broken down into 2 parts.
the filename before a colon (:) and the key after the colon. This means
when we have a filename like:</font>
<p><tt><font color="#000099">/path/to/file.jpg</font></tt>
<p><font color="#000000">the filename is:</font>
<p><tt><font color="#000099">/path/to/file.jpg</font></tt>
<p><font color="#000000">and the key is blank. If we have:</font>
<p><tt><font color="#000099">/path/to/file.db:key.value/blah</font></tt>
<p><font color="#000000">the filename is:</font>
<p><tt><font color="#000099">/path/to/file.db</font></tt>
<p><font color="#000000">and the key is:</font>
<p><tt><font color="#000099">key.value/blah</font></tt>
<p><font color="#000000">You may ask what is this thing with keys and filenames?
Well Imlib2 has loaders that are able to load data that is WITHIN a file
(the loader capable of this right now is the database loader that is able
to load image data stored with a key in a Berkeley-db database file). The
colon is used to delimit where the filename ends and the key begins. Fro
the majority of files you load you won't have to worry, but there is a
limit in this case that filenames cannot contain a color character.</font>
<p><font color="#000000">First Imlib2 checks to see if the file exists
and that you have permission to read it. If this fails it will abort the
load. Now that it has checked that this is the case it evaluates that it's
list of dynamically loaded loader modules it up to date then it runs through
the loader modules until one of them claims it can load this file. If this
is the case  that loader is now used to decode the image and return
an Image handle to the calling program. If the loader is written correctly
and the file format sanely supports this, the loader will NOT decode any
image data at this point. It will ONLY read the header of the image to
figure out its size, if it has an alpha channel, format and any other header
information. The loader is remembered and it will be re-used to load the
image data itself later if and ONLY if the actual image data itself is
needed. This means you can scan vast directories of files figuring their
format and size and other such information just by loading and freeing
- and it will be fast because no image data is decoded. You can take advantage
of this by loading the image and checking its size to calculate the size
of an output area before you ever load the data. This means  geometry
calculations can be done fast ahead of time.</font>
<p><font color="#000000">If you desire more detailed information about
why a load failed you can use </font><tt><font color="#000099">imlib_load_image_with_error_return();
</font></tt><font color="#000000">and
it will return a detailed error return code.</font>
<p><font color="#000000">If you do not wish to have the image data loaded
later using the optimized "deferred" method of loading, you can force the
data to be decoded immediately with </font><tt><font color="#000099">imlib_load_image_immediately();</font></tt>
<p><font color="#000000">If you wish to bypass the cache when loading images
you can using </font><tt><font color="#000099">imlib_load_image_without_cache();
</font></tt><font color="#000000">and
</font><tt><font color="#000099">imlib_load_image_immediately_without_cache();</font></tt><font color="#000000">.</font>
<p><font color="#000000">Sometimes loading images can take a while. Often
it is a good idea to provide feedback to the user whilst this is happening.
This is when you set the progress function callback. Setting this to NULL
will mean no progress function is called during load - this is the default.
When it is set you set it to a function that will get called every so often
(depending on the progress granularity) during load. Use </font><tt><font color="#000099">imlib_context_set_progress_function();</font></tt><font color="#000000">
and </font><tt><font color="#000099">imlib_context_set_progress_granularity();
</font></tt><font color="#000000">to
set this up.</font></blockquote>
</td>

<td><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br> 
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>A
more advanced Example</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="img/blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#6a7a8a" NOSAVE>This is a more comprehensive
example that should show off a fair number of features of imlib2. The code
this was based off can be found in Imlib2's test directory. This covers
a lot of the core of Imlib2's API so you should have a pretty good idea
on how it works if you understand this code snippet.
<blockquote>
<pre><tt><font color="#660000">/* include X11 stuff */
#include &lt;X11/Xlib.h>
/* include Imlib2 stuff */
#include &lt;Imlib2.h>
/* sprintf include */
#include &lt;stdio.h>

/* some globals for our window &amp; X display */
Display *disp;
Window   win;
Visual  *vis;
Colormap cm;
int      depth;

/* the program... */
int main(int argc, char **argv)
{
   /* events we get from X */
   XEvent ev;
   /* areas to update */
   Imlib_Updates updates, current_update;
   /* our virtual framebuffer image we draw into */
   Imlib_Image buffer;
   /* a font */
   Imlib_Font font;
   /* our color range */
   Imlib_Color_Range range;
   /* our mouse x, y coordinates */
   int mouse_x = 0, mouse_y = 0;
   
   /* connect to X */
   disp  = XOpenDisplay(NULL);
   /* get default visual , colormap etc. you could ask imlib2 for what it */
   /* thinks is the best, but this example is intended to be simple */
   vis   = DefaultVisual(disp, DefaultScreen(disp));
   depth = DefaultDepth(disp, DefaultScreen(disp));
   cm    = DefaultColormap(disp, DefaultScreen(disp));
   /* create a window 640x480 */
   win = XCreateSimpleWindow(disp, DefaultRootWindow(disp), 
                             0, 0, 640, 480, 0, 0, 0);
   /* tell X what events we are interested in */
   XSelectInput(disp, win, ButtonPressMask | ButtonReleaseMask | 
                PointerMotionMask | ExposureMask);
   /* show the window */
   XMapWindow(disp, win);
   /* set our cache to 2 Mb so it doesn't have to go hit the disk as long as */
   /* the images we use use less than 2Mb of RAM (that is uncompressed) */
   imlib_set_cache_size(2048 * 1024);
   /* set the font cache to 512Kb - again to avoid re-loading */
   imlib_set_font_cache_size(512 * 1024);
   /* add the ./ttfonts dir to our font path - you'll want a notepad.ttf */
   /* in that dir for the text to display */
   imlib_add_path_to_font_path("./ttfonts");
   /* set the maximum number of colors to allocate for 8bpp and less to 128 */
   imlib_set_color_usage(128);
   /* dither for depths &lt; 24bpp */
   imlib_context_set_dither(1);
   /* set the display , visual, colormap and drawable we are using */
   imlib_context_set_display(disp);
   imlib_context_set_visual(vis);
   imlib_context_set_colormap(cm);
   imlib_context_set_drawable(win);
   /* infinite event loop */
   for (;;)
     {
        /* image variable */
        Imlib_Image image;
        /* width and height values */
        int w, h, text_w, text_h;
        
        /* init our updates to empty */
        updates = imlib_updates_init();
        /* while there are events form X - handle them */
        do
          {
             XNextEvent(disp, &amp;ev);
             switch (ev.type)
               {
               case Expose:
                  /* window rectangle was exposed - add it to the list of */
                  /* rectangles we need to re-render */
                  updates = imlib_update_append_rect(updates,
                                                     ev.xexpose.x, ev.xexpose.y,
                                                     ev.xexpose.width, ev.xexpose.height);
                  break;
               case ButtonPress:
                  /* if we click anywhere in the window, exit */
                  exit(0);
                  break;
               case MotionNotify:
                  /* if the mouse moves - note it */
                  /* add a rectangle update for the new mouse position */
                  image = imlib_load_image("./test_images/mush.png");
                  imlib_context_set_image(image);
                  w = imlib_image_get_width();
                  h = imlib_image_get_height();
                  imlib_context_set_image(image);
                  imlib_free_image();
                  /* the old position - so we wipe over where it used to be */
                  updates = imlib_update_append_rect(updates,
                                                     mouse_x - (w / 2), mouse_y - (h / 2),
                                                     w, h);
                  font = imlib_load_font("notepad/30");
                  if (font)
                    {
                       char text[4096];
                       
                       imlib_context_set_font(font);
                       sprintf(text, "Mouse is at %i, %i", mouse_x, mouse_y);
                       imlib_get_text_size(text, &amp;text_w, &amp;text_h); 
                       imlib_free_font();
                       updates = imlib_update_append_rect(updates,
                                                          320 - (text_w / 2), 240 - (text_h / 2),
                                                          text_w, text_h);
                    }
                  
                  mouse_x = ev.xmotion.x;
                  mouse_y = ev.xmotion.y;
                  /* the new one */
                  updates = imlib_update_append_rect(updates,
                                                     mouse_x - (w / 2), mouse_y - (h / 2),
                                                     w, h);
                  font = imlib_load_font("notepad/30");
                  if (font)
                    {
                       char text[4096];
                       
                       imlib_context_set_font(font);
                       sprintf(text, "Mouse is at %i, %i", mouse_x, mouse_y);
                       imlib_get_text_size(text, &amp;text_w, &amp;text_h); 
                       imlib_free_font();
                       updates = imlib_update_append_rect(updates,
                                                          320 - (text_w / 2), 240 - (text_h / 2),
                                                          text_w, text_h);
                    }
               default:
                  /* any other events - do nothing */
                  break;
               }
          }
        while (XPending(disp));
        
        /* no more events for now ? ok - idle time so lets draw stuff */
        
        /* take all the little rectangles to redraw and merge them into */
        /* something sane for rendering */
        updates = imlib_updates_merge_for_rendering(updates, 640, 480);
        for (current_update = updates; 
             current_update; 
             current_update = imlib_updates_get_next(current_update))
          {
             int up_x, up_y, up_w, up_h;

             /* find out where the first update is */
             imlib_updates_get_coordinates(current_update, 
                                           &amp;up_x, &amp;up_y, &amp;up_w, &amp;up_h);
             
             /* create our buffer image for rendering this update */
             buffer = imlib_create_image(up_w, up_h);
             
             /* we can blend stuff now */
             imlib_context_set_blend(1);
             
             /* fill the window background */
             /* load the background image - you'll need to have some images */
             /* in ./test_images lying around for this to actually work */
             image = imlib_load_image("./test_images/bg.png");
             /* we're working with this image now */
             imlib_context_set_image(image);
             /* get its size */
             w = imlib_image_get_width();
             h = imlib_image_get_height();
             /* now we want to work with the buffer */
             imlib_context_set_image(buffer);
             /* if the iimage loaded */
             if (image) 
               {
                  /* blend image onto the buffer and scale it to 640x480 */
                  imlib_blend_image_onto_image(image, 0, 
                                               0, 0, w, h, 
                                               - up_x, - up_y, 640, 480);
                  /* working with the loaded image */
                  imlib_context_set_image(image);
                  /* free it */
                  imlib_free_image();
               }
             
             /* draw an icon centered around the mouse position */
             image = imlib_load_image("./test_images/mush.png");
             imlib_context_set_image(image);
             w = imlib_image_get_width();
             h = imlib_image_get_height();
             imlib_context_set_image(buffer);
             if (image) 
               {
                  imlib_blend_image_onto_image(image, 0, 
                                               0, 0, w, h, 
                                               mouse_x - (w / 2) - up_x, mouse_y - (h / 2) - up_y, w, h);
                  imlib_context_set_image(image);
                  imlib_free_image();
               }
             
             /* draw a gradient on top of things at the top left of the window */
             /* create a range */
             range = imlib_create_color_range();
             imlib_context_set_color_range(range);
             /* add white opaque as the first color */
             imlib_context_set_color(255, 255, 255, 255);
             imlib_add_color_to_color_range(0);
             /* add an orange color, semi-transparent 10 units from the first */
             imlib_context_set_color(255, 200, 10, 100);
             imlib_add_color_to_color_range(10);
             /* add black, fully transparent at the end 20 units away */
             imlib_context_set_color(0, 0, 0, 0);
             imlib_add_color_to_color_range(20);
             /* draw the range */
             imlib_context_set_image(buffer);
             imlib_image_fill_color_range_rectangle(- up_x, - up_y, 128, 128, -45.0);
             /* free it */
             imlib_free_color_range();
             
             /* draw text - centered with the current mouse x, y */
             font = imlib_load_font("notepad/30");
             if (font)
               {
                  char text[4096];
                  
                  /* set the current font */
                  imlib_context_set_font(font);
                  /* set the image */
                  imlib_context_set_image(buffer);
                  /* set the color (black) */
                  imlib_context_set_color(0, 0, 0, 255);
                  /* print text to display in the buffer */
                  sprintf(text, "Mouse is at %i, %i", mouse_x, mouse_y);
                  /* query the size it will be */
                  imlib_get_text_size(text, &amp;text_w, &amp;text_h); 
                  /* draw it */
                  imlib_text_draw(320 - (text_w / 2) - up_x, 240 - (text_h / 2) - up_y, text); 
                  /* free the font */
                  imlib_free_font();
               }
             
             /* don't blend the image onto the drawable - slower */
             imlib_context_set_blend(0);
             /* set the buffer image as our current image */
             imlib_context_set_image(buffer);
             /* render the image at 0, 0 */
             imlib_render_image_on_drawable(up_x, up_y);
             /* don't need that temporary buffer image anymore */
             imlib_free_image();
          }
        /* if we had updates - free them */
        if (updates)
           imlib_updates_free(updates);
        /* loop again waiting for events */
     }
   return 0;
}</font></tt></pre>
</blockquote>
</td>

<td><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br> 
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>API
Reference</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td>
<img SRC="img/blank.gif" height=1 width=1>
</td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#6a7a8a" NOSAVE><p>This is a list of
all the Imlib2 API calls and what each of them do. You should familiarize
yourself well with this API so you have a good idea of what can be done.</p>
<b><tt><font color="#660000"><font size=+2>void imlib_context_set_display(Display *display);</font></font></tt></b>

<blockquote>Sets the current X display to be used for rendering of images
to drawables. You do not need to set this if you do not intend to render
an image to an X drawable. If you do you will need to set this. If you
change displays just set this to the new display pointer. Do not use a
Display pointer if you have closed that display already - also note that
if you close a display connection and continue to render using Imlib2 without
setting the display pointer to NULL or something new, crashes may occur.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_visual(Visual *visual);</font></font></tt></b>

<blockquote>This sets the current visual to use when rendering images to
drawables or producing pixmaps. You need to set this for anything to render
to a drawable or produce any pixmaps (this can be the default visual).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_colormap(Colormap colormap);</font></font></tt></b>

<blockquote>Sets the colormap to use when rendering to drawables and allocating
colors. You must set this to the colormap you are using to render any images
or produce any pixmaps (this can be the default colormap).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_drawable(Drawable drawable);</font></font></tt></b>

<blockquote>This sets the X drawable to which images will be rendered when
you call a render call in Imlib2. This may be either a pixmap or a window.
You must set this to render anything.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_mask(Pixmap mask);</font></font></tt></b>

<blockquote>This sets the 1-bit deep pixmap to be drawn to when rendering
to generate a mask pixmap. This is only useful if the image you are rendering
has alpha. Set this to 0 to not render a pixmap mask.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_dither_mask(char dither_mask);</font></font></tt></b>

<blockquote>Selects if, you are rendering to a mask, or producing pixmap
masks from images, if the mask is to be dithered or not. passing in 1 for
dither_mask means the mask pixmap will be dithered, 0 means it will not
be dithered.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_anti_alias(char anti_alias);</font></font></tt></b>

<blockquote>Toggles "anti-aliased" scaling of images. This isn't quite
correct since it's actually super and sub pixel sampling that it turns
on and off, but anti-aliasing is used for having "smooth" edges to lines
and shapes and this means when images are scaled they will keep their smooth
appearance. Passing in 1 turns this on and 0 turns it off.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_dither(char dither);</font></font></tt></b>

<blockquote>Sets the dithering flag for rendering to a drawable or when
pixmaps are produced. This affects the color image appearance by enabling
dithering. Dithering slows down rendering but produces considerably better
results. this option has no effect foe rendering in 24 bit and up, but
in 16 bit and lower it will dither, producing smooth gradients and much
better quality images. setting dither to 1 enables it and 0 disables it.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_blend(char blend);</font></font></tt></b>

<blockquote>When rendering an image to a drawable, Imlib2 is able to blend
the image directly onto the drawable during rendering. setting this to
1 will enable this. If the image has no alpha channel this has no effect.
Setting it to 0 will disable this.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color_modifier(Imlib_Color_Modifier color_modifier);</font></font></tt></b>

<blockquote>This sets the current color modifier used for rendering pixmaps
or images to a drawable or images onto other images. Color modifiers are
lookup tables that map the values in the red, green, blue and alpha channels
to other values in the same channel when rendering, allowing for fades,
color correction etc. to be done whilst rendering. pass in NULL as the
color_modifier to disable the color modifier for rendering.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_operation(Imlib_Operation operation);</font></font></tt></b>

<blockquote>When Imlib2 draws an image onto another or an image onto a
drawable it is able to do more than just blend the result on using the
given alpha channel of the image. It is also able to do saturating additive,
subtractive and a combination of the both (called reshade) rendering. The
default mode is IMLIB_OP_COPY. you can also set it to IMLIB_OP_ADD, IMLIB_OP_SUBTRACT
or IMLIB_OP_RESHADE. Use this function to set the rendering operation.
IMLIB_OP_COPY performs basic alpha blending: DST = (SRC * A) + (DST * (1
- A)). IMLIB_OP_ADD does DST = DST + (SRC * A). IMLIB_OP_SUBTRACT does
DST = DST - (SRC * A) and IMLIB_OP_RESHADE does DST = DST + (((SRC - 0.5)
/ 2) * A).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_font(Imlib_Font font);</font></font></tt></b>

<blockquote>This function sets the current font to use when rendering text.
you should load the font first with imlib_load_font().</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_direction(Imlib_Text_Direction direction);</font></font></tt></b>

<blockquote>This sets the direction in which to draw text in terms of simple
90 degree orientations or an arbitrary angle. The direction can be one
of IMLIB_TEXT_TO_RIGHT, IMLIB_TEXT_TO_LEFT, IMLIB_TEXT_TO_DOWN, IMLIB_TEXT_TO_UP
or IMLIB_TEXT_TO_ANGLE. The default is IMLIB_TEXT_TO_RIGHT. If you use
IMLIB_TEXT_TO_ANGLE, you will also have to set the angle with imlib_context_set_angle().</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_angle(double angle);</font></font></tt></b>

<blockquote>This sets the angle at which text strings will be drawn if
the text direction has been set to IMLIB_TEXT_TO_ANGLE with imlib_context_set_direction().</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color(int red, int green, int blue, int alpha);</font></font></tt></b>

<blockquote>This sets the color with which text, lines and rectangles are
drawn when being rendered onto an image. Values for red, green, blue and
alpha are between 0 and 255 - any other values have undefined results.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color_cmya(int cyan, magenta, int yellow, int alpha);</font></font></tt></b>

<blockquote>This sets the color in CMYA space. Values for cyan, magenta,
yellow and alpha are between 0 and 255 - any other values have undefined results.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color_hsva(float hue, float saturation, float value, int alpha);</font></font></tt></b>

<blockquote>This sets the color in HSVA space. Values for hue are between 0 and 360,
values for saturation and value between 0 and 1, and values for alpha are between 0
and 255 - any other values have undefined results.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color_hlsa(float hue, float lightness, float saturation, int alpha);</font></font></tt></b>

<blockquote>This sets the color in HLSA space. Values for hue are between 0 and 360,
values for lightness and saturation between 0 and 1, and values for alpha are 
between 0 and 255 - any other values have undefined results.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_color_range(Imlib_Color_Range color_range);</font></font></tt></b>

<blockquote>This sets the current color range to use for rendering gradients.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_progress_function(Imlib_Progress_Function progress_function);</font></font></tt></b>

<blockquote>This sets the progress function to be called back whilst loading
images. Set this to the function to be called, or set it to NULL to disable
progress callbacks whilst loading.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_progress_granularity(char progress_granularity);</font></font></tt></b>

<blockquote>This hints as to how often to call the progress callback. 0
means as often as possible. 1 means whenever 15 more of the image has been
decoded, 10 means every 10% of the image decoding, 50 means every 50% and
100 means only call at the end. Values outside of the range 0-100 are undefined.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_image(Imlib_Image image);</font></font></tt></b>

<blockquote>This sets the current image Imlib2 will be using with its function
calls.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_filter(Imlib_Filter filter);</font></font></tt></b>

<blockquote>This sets the current filter to be used when applying filters
to images. Set this to NULL to disable filters.</blockquote>

<b><tt><font color="#660000"><font size=+2>Display *imlib_context_get_display(void);</font></font></tt></b>

<blockquote>This returns the current display used for Imlib2's display
context.</blockquote>

<b><tt><font color="#660000"><font size=+2>Visual *imlib_context_get_visual(void);</font></font></tt></b>

<blockquote>Returns the current visual used for Imlib2's context.</blockquote>

<b><tt><font color="#660000"><font size=+2>Colormap imlib_context_get_colormap(void);</font></font></tt></b>

<blockquote>Returns the current Colormap used for Imlib2's context.</blockquote>

<b><tt><font color="#660000"><font size=+2>Drawable imlib_context_get_drawable(void);</font></font></tt></b>

<blockquote>Returns the current Drawable used for Imlib2's context.</blockquote>

<b><tt><font color="#660000"><font size=+2>Pixmap imlib_context_get_mask(void);</font></font></tt></b>

<blockquote>Returns the current pixmap destination to be used to render
a mask into.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_context_get_dither_mask(void);</font></font></tt></b>

<blockquote>Returns the current mode for dithering pixmap masks. 1 means
dithering is enabled and 0 means it is not.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_context_get_anti_alias(void);</font></font></tt></b>

<blockquote>Returns if Imlib2 currently will smoothly scale images. 1 means
it will and 0 means it will not.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_context_get_dither(void);</font></font></tt></b>

<blockquote>Returns if image data is rendered with dithering currently.
1 means yes and 0 means no.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_context_get_blend(void);</font></font></tt></b>

<blockquote>Returns if Imlib2 will blend images onto a drawable whilst
rendering to that drawable. 1 means yes and 0 means no.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Color_Modifier imlib_context_get_color_modifier(void);</font></font></tt></b>

<blockquote>Returns the current colormodifier being used.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Operation imlib_context_get_operation(void);</font></font></tt></b>

<blockquote>Returns the current operation mode.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Font imlib_context_get_font(void);</font></font></tt></b>

<blockquote>Returns the current font.</blockquote>

<b><tt><font color="#660000"><font size=+2>double imlib_context_get_angle(void);</font></font></tt></b>

<blockquote>Returns the current angle used to render text at if the direction
is IMLIB_TEXT_TO_ANGLE.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Text_Direction imlib_context_get_direction(void);</font></font></tt></b>

<blockquote>Returns the current direction to render text in.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_get_color(int *red, int *green, int *blue, int *alpha);</font></font></tt></b>

<blockquote>Returns the current color for rendering text, rectangles and
lines.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_get_color_cmya(int *cyan, int *magenta, int *yellow, int *alpha);</font></font></tt></b>

<blockquote>Returns the current color for rendering text, rectangles and
lines in CMYA space.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_get_color_hsva(float *hue, float *saturation, float *value, int *alpha);</font></font></tt></b>

<blockquote>Returns the current color for rendering text, rectangles and
lines in HSVA space.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_get_color_hlsa(float *hue, float * lightness, float *saturation, int *alpha);</font></font></tt></b>

<blockquote>Returns the current color for rendering text, rectangles and
lines in HLSA space.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Color *imlib_context_get_imlib_color(void);</font></font></tt></b>

<blockquote>Returns the current color as a color struct. Do NOT free this
pointer.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Color_Range imlib_context_get_color_range(void);</font></font></tt></b>

<blockquote>Return the current color range being used for gradients.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Progress_Function imlib_context_get_progress_function(void);</font></font></tt></b>

<blockquote>Return the current progress function being used.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_context_get_progress_granularity(void);</font></font></tt></b>

<blockquote>Get the current progress granularity being used.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_context_get_image(void);</font></font></tt></b>

<blockquote>Return the current context image.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Filter imlib_context_get_filter(void);</font></font></tt></b>

<blockquote>Get the current context image filter.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_cache_size(void);</font></font></tt></b>

<blockquote>Return the current size of the image cache in bytes. The cache
is a unified cache used for image data AND pixmaps.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_set_cache_size(int bytes);</font></font></tt></b>

<blockquote>Set the cache size. The size is in bytes. Setting the cache
size to 0 effectively flushes the cache and keeps the cache size at 0 until
set to another value. Whenever you set the cache size Imlib2 will flush
as many old images and pixmap from the cache as needed until the current
cache usage is less than or equal to the cache size.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_color_usage(void);</font></font></tt></b>

<blockquote>Get the number of colors Imlib2 currently at a maximum is allowed
to allocate for rendering. The default is 256.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_set_color_usage(int max);</font></font></tt></b>

<blockquote>Set the maximum number of colors you would like Imlib2 to allocate
for you when rendering. The default ids 256. This has no effect in depths
greater than 8 bit.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_flush_loaders(void);</font></font></tt></b>

<blockquote>If you want Imlib2 to forcibly flush any cached loaders it
has and re-load them from disk (this is useful if the program just installed
a new loader and does not want to wait till Imlib2 deems it an optimal
time to rescan the loaders)</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_visual_depth(Display *display, Visual *visual);</font></font></tt></b>

<blockquote>Convenience function that returns the depth of a visual for
that display.</blockquote>

<b><tt><font color="#660000"><font size=+2>Visual *imlib_get_best_visual(Display *display, int screen, int *depth_return);</font></font></tt></b>

<blockquote>Returns the visual for that display and screen that Imlib2
thinks will give you the best quality output. depth_return should point
to an int that will be filled with the depth of that visual too.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_load_image(const char *file);</font></font></tt></b>

<blockquote>This function loads an image from disk located at the path
specified by file. Please see the "How image loading works" section for
more detail. Returns an image handle on success or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_load_image_immediately(const char *file);</font></font></tt></b>

<blockquote>Loads an image from disk located at the path specified by file.
This forces the image data to be decoded at load time too, instead of decoding
being deferred until it is needed. Returns an image handle on success or
NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_load_image_without_cache(const char *file);</font></font></tt></b>

<blockquote>This loads the image without looking in the cache first. Returns
an image handle on success or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_load_image_immediately_without_cache(const char *file);</font></font></tt></b>

<blockquote>Loads the image without deferred image data decoding (i.e.
it is decoded straight away) and without looking in the cache. Returns
an image handle on success or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_load_image_with_error_return(const char *file, Imlib_Load_Error *error_return);</font></font></tt></b>

<blockquote>This loads an image at the path file on disk. If it succeeds
it returns a valid image handle, if not NULL is returned and the error_return
pointed to is set to the detail of the error.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_image(void);</font></font></tt></b>

<blockquote>This frees the image that is set as the current image in Imlib2's
context.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_image_and_decache(void);</font></font></tt></b>

<blockquote>Frees the current image in Imlib2's context AND removes it
from the cache.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_image_get_width(void);</font></font></tt></b>

<blockquote>Returns the width in pixels of the current image in Imlib2's
context.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_image_get_height(void);</font></font></tt></b>

<blockquote>Returns the height in pixels of the current image in Imlib2's
context.</blockquote>

<b><tt><font color="#660000"><font size=+2>const char *imlib_image_get_filename(void);</font></font></tt></b>

<blockquote>This returns the filename for the file that is set as the current
context. The pointer returned is only valid as long as no operations cause
the filename of the image to change. Saving the file with a different name
would cause this. It is suggested you duplicate the string if you wish
to continue to use the string for later processing. Do not free the string
pointer returned by this function.</blockquote>

<b><tt><font color="#660000"><font size=+2>DATA32 *imlib_image_get_data(void);</font></font></tt></b>

<blockquote>This returns a pointer to the image data in the image set as
the image for the current context. When you get this pointer it is assumed
you are planning on writing to the data, thus once you do this the image
can no longer be used for caching - in fact all images cached from this
one will also be affected when you put the data back. If this matters it
is suggested you clone the image first before playing with the image data.
The image data is returned in the format of a DATA32 (32 bits) per pixel
in a linear array ordered from the top left of the image to the bottom
right going from left to right each line. Each pixel has the upper 8 bits
as the alpha channel and the lower 8 bits are the blue channel - so a pixel's
bits are ARGB (from most to least significant, 8 bits per channel). You
must put the data back at some point.</blockquote>

<b><tt><font color="#660000"><font size=+2>DATA32 *imlib_image_get_data_for_reading_only(void);</font></font></tt></b>

<blockquote>This functions the same way as imlib_image_get_data(), but
returns a pointer expecting the program to NOT write to the data returned
(it is for inspection purposes only). Writing to this data has undefined
results. The data does not need to be put back.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_put_back_data(DATA32 *data);</font></font></tt></b>

<blockquote>This will put back data when it was obtained by imlib_image_get_data().
The data must be the same pointer returned by imlib_image_get_data(). This
operated on the current context image.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_image_has_alpha(void);</font></font></tt></b>

<blockquote>Returns 1 if the current context image has an alpha channel,
or 0 if it does not (the alpha data space is still there and available
- just "unused").</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_changes_on_disk(void);</font></font></tt></b>

<blockquote>By default Imlib2 will not check the timestamp of an image
on disk and compare it with the image in its cache - this is to minimize
disk activity when using the cache. Call this function and it will flag
the current context image as being liable to change on disk and Imlib2
will check the timestamp of the image file on disk and compare it with
the cached image when it next needs to use this image in the cache.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_get_border(Imlib_Border *border);</font></font></tt></b>

<blockquote>This function fills the Imlib_Border structure to which border
points to with the values of the border of the current context image. The
border is the area at the edge of the image that does not scale with the
rest of the image when resized - the borders remain constant in size. This
is useful for scaling bevels at the edge of images differently to the image
center.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_border(Imlib_Border *border);</font></font></tt></b>

<blockquote>This sets the border of the current context image to the values
contained in the Imlib_Border structure border points to.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_format(const char *format);</font></font></tt></b>

<blockquote>This sets the format of the current image. This is used for
when you wish to save an image in a different format that it was loaded
in, or if the image currently has no file format associated with it.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_irrelevant_format(char irrelevant);</font></font></tt></b>

<blockquote>This sets if the format value of the current image is irrelevant
for caching purposes - by default it is. pass irrelevant as 1 to make it
irrelevant and 0 to make it relevant for caching.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_irrelevant_border(char irrelevant);</font></font></tt></b>

<blockquote>This sets if the border of the current image is irrelevant
for caching purposes. By default it is. Set irrelevant to 1 to make it
irrelevant, and 0 to make it relevant.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_irrelevant_alpha(char irrelevant);</font></font></tt></b>

<blockquote>This sets if the alpha channel status of the current image
(i.e. if there is or is not one) is important for caching purposes. By
default it is not. Set irrelevant to 1 to make it irrelevant and 0 to make
it relevant.</blockquote>

<b><tt><font color="#660000"><font size=+2>char *imlib_image_format(void);</font></font></tt></b>

<blockquote>This returns the current image's format. Do not free this string.
Duplicate it if you need it for later use.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_set_has_alpha(char has_alpha);</font></font></tt></b>

<blockquote>Sets the alpha flag for the current image. Set has_alpha to
1 to enable the alpha channel in the current image, or 0 to disable it.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_pixmaps_for_whole_image(Pixmap *pixmap_return, Pixmap *mask_return);</font></font></tt></b>

<blockquote>This function will create a pixmap of the current image (and
a mask if the image has an alpha value) and return the id's of the pixmap
and mask to the pixmap_return and mask_return pixmap id's. You must free
these pixmaps using Imlib2's free function imlib_free_pixmap_and_mask();.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_pixmaps_for_whole_image_at_size(Pixmap *pixmap_return, Pixmap *mask_return, int width, int height);</font></font></tt></b>

<blockquote>This function works just like imlib_render_pixmaps_for_whole_image(),
but will scale the output result to the width and height specified. Scaling
is done before depth conversion so pixels used for dithering don't grow
large.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_pixmap_and_mask(Pixmap pixmap);</font></font></tt></b>

<blockquote>This will free the pixmap (and any mask generated in association
with that pixmap). The pixmap will remain cached until the image the pixmap
was generated from is dirtied or decached, or the cache is flushed.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_on_drawable(int x, int y);</font></font></tt></b>

<blockquote>This renders the current image onto the current drawable at
the x, y pixel location specified without scaling.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_on_drawable_at_size(int x, int y, int width, int height);</font></font></tt></b>

<blockquote>This will render the current image onto the current drawable
at the x, y location specified AND scale the image to the width and height
specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_part_on_drawable_at_size(int source_x, int source_y, int source_width, int source_height, int x, int y, int width, int height);</font></font></tt></b>

<blockquote>This renders the source x, y, width, height pixel rectangle
from the current image onto the current drawable at the x, y location scaled
to the width and height specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_blend_image_onto_image(Imlib_Image source_image, char merge_alpha, int source_x, int source_y, int source_width, int source_height, int destination_x, int destination_y, int destination_width, int destination_height);</font></font></tt></b>

<blockquote>This will blend the source rectangle x, y, width, height from
the source_image onto the current image at the destination x, y location
scaled to the width and height specified. If merge_alpha is set to 1 it
will also modify the destination image alpha channel, otherwise the destination
alpha channel is left untouched.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_image(int width, int height);</font></font></tt></b>

<blockquote>This creates a new blank image of size width and height. The
contents of this image at creation time are undefined (they could be garbage
memory). You are free to do whatever you like with this image. It is not
cached. On success an image handle is returned - on failure NULL is returned.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_image_using_data(int width, int height, DATA32 *data);</font></font></tt></b>

<blockquote>This creates an image from the image data specified with the
width and height specified. The image data must be in the same format as
imlib_image_get_data() would return. You are responsible for freeing this
image data once the image is freed - Imlib2 will not do that for you. This
is useful for when you already have static buffers of the same format Imlib2
uses (many video grabbing devices use such a format) and wish to use Imlib2
to render the results onto another image, or X drawable. You should free
the image when you are done with it. Imlib2 returns a valid image handle
on success or NULL on failure</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_image_using_copied_data(int width, 
                                                 int height, 
                                                 DATA32 *data);</font></font></tt></b>

<blockquote>This works the same way as imlib_create_image_using_data()
but Imlib2 copies the image data to the image structure. You may now do
whatever you wish with the original data as it will not be needed anymore.
Imlib2 returns a valid image handle on success or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_image_from_drawable(Pixmap mask, 
                                             int x, 
                                             int y, 
                                             int width, 
                                             int height, 
                                             char need_to_grab_x);</font></font></tt></b>

<blockquote>This will return an image (using the mask to determine the
alpha channel) from the current drawable. If the mask is 0 it will not
create a useful alpha channel in the image. It will create an image from
the x, y, width , height rectangle in the drawable. If need_to_grab_x is
1 it will also grab the X Server to avoid possible race conditions in grabbing.
If you have not already grabbed the server you MUST set this to 1. Imlib2
returns a valid image handle on success or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_scaled_image_from_drawable(Pixmap mask, 
                                                    int source_x, 
                                                    int source_y, 
                                                    int source_width, 
                                                    int source_height, 
                                                    int destination_width, 
                                                    int destination_height, 
                                                    char need_to_grab_x, 
                                                    char get_mask_from_shape);</font></font></tt></b>

<blockquote>This will create an image from the current drawable (optionally
using the mask pixmap specified to determine alpha transparency) and scale
the grabbed data first before converting to an actual image (to minimize
reads from the frame buffer which can be slow). The source x, y, width,
height rectangle will be grabbed, scaled to the destination width and height,
then converted to an image. If need_to_grab_x is set to 1, X is grabbed
(set this to 1 unless you have already grabbed the server) and if get_mask_from_shape
and the current drawable is a window its shape is used for determining
the alpha channel. If successful this function will return a valid image
handle, otherwise NULL is returned.</blockquote>

<b><tt><font color="#660000"><font size=+2>char imlib_copy_drawable_to_image(Pixmap mask, 
                                  int x, 
                                  int y, 
                                  int width, 
                                  int height, 
                                  int destination_x, 
                                  int destination_y, 
                                  char need_to_grab_x);</font></font></tt></b>

<blockquote>This routine will grab a section of the current drawable (optionally
using the pixmap provided as a corresponding mask for that drawable - if
mask is 0 this is not used). It grabs the x, y, width, height rectangle
and places it at the destination x, y location in the current image. If
need_to_grab_x is 1 it will grab and ungrab the server whilst doing this
- you need to do this if you have not already grabbed the server.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_clone_image(void);</font></font></tt></b>

<blockquote>This creates an exact duplicate of the current image and returns
a valid image handle on success, or NULL on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_cropped_image(int x, 
                                       int y, 
                                       int width, 
                                       int height);</font></font></tt></b>

<blockquote>This creates a duplicate of a x, y, width, height rectangle
in the current image and returns a valid image handle on success, or NULL
on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_cropped_scaled_image(int source_x, 
                                              int source_y, 
                                              int source_width, 
                                              int source_height, 
                                              int destination_width, 
                                              int destination_height);</font></font></tt></b>

<blockquote>This function works the same as imlib_create_cropped_image()
but will scale the new image to the new destination width and height whilst
cropping.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_clone(Imlib_Updates updates);</font></font></tt></b>

<blockquote>This function creates a duplicate of the updates list passed
into the function.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_update_append_rect(Imlib_Updates updates, 
                                       int x, 
                                       int y, 
                                       int w, 
                                       int h);</font></font></tt></b>

<blockquote>This function appends an update rectangle to the updates list
passed in (if the updates is NULL it will create a new updates list) and
returns a handle to the modified updates list (the handle may be modified
so only use the new updates handle returned)</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_merge(Imlib_Updates updates, 
                                  int w, 
                                  int h);</font></font></tt></b>

<blockquote>This function takes an updates list, and modifies it by merging
overlapped rectangles and lots of tiny rectangles into larger rectangles
to minimize the number of rectangles in the list for optimized redrawing.
The new updates handle is now valid and the old one passed in is not.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_merge_for_rendering(Imlib_Updates updates, 
                                                int w, 
                                                int h);</font></font></tt></b>

<blockquote>This works almost exactly as imlib_updates_merge() but is more
lenient on the spacing between update rectangles - if they are very close
it amalgamates 2 smaller rectangles into 1 larger one.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_updates_free(Imlib_Updates updates);</font></font></tt></b>

<blockquote>This frees an updates list.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_get_next(Imlib_Updates updates);</font></font></tt></b>

<blockquote>This gets the next update in the updates list relative to the
one passed in.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_updates_get_coordinates(Imlib_Updates updates, 
                                   int *x_return, 
                                   int *y_return, 
                                   int *width_return, 
                                   int *height_return);</font></font></tt></b>

<blockquote>This returns the coordinates of an update.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_updates_set_coordinates(Imlib_Updates updates, 
                                   int x, 
                                   int y, 
                                   int width, 
                                   int height);</font></font></tt></b>

<blockquote>This modifies the coordinates of an update in an updates list.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_updates_on_drawable(Imlib_Updates updates, 
                                            int x, 
                                            int y);</font></font></tt></b>

<blockquote>Given an updates list (preferable already merged for rendering)
this will render the corresponding parts of the image to the current drawable
at an offset of x, y in the drawable.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_init(void);</font></font></tt></b>

<blockquote>This initializes an updates list before you add any updates
to it or merge it for rendering etc.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_updates_append_updates(Imlib_Updates updates, 
                                           Imlib_Updates appended_updates);</font></font></tt></b>

<blockquote>This appends one updates list (appended_updates) to the updates
list (updates) and returns the new list.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_flip_horizontal(void);</font></font></tt></b>

<blockquote>This will flip/mirror the current image horizontally.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_flip_vertical(void);</font></font></tt></b>

<blockquote>This will flip/mirror the current image vertically.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_flip_diagonal(void);</font></font></tt></b>

<blockquote>This will flip/mirror the current image diagonally (good for
quick and dirty 90 degree rotations if used before to after a horizontal
or vertical flip).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_orientate(int orientation);</font></font></tt></b>

<blockquote>This will perform 90 degree rotations on the current image.
Passing in orientation does not rotate, 1 rotates clockwise by 90 degree,
2, rotates clockwise by 180 degrees, 3 rotates clockwise by 270 degrees.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_blur(int radius);</font></font></tt></b>

<blockquote>This will blur the current image. A radius of 0 has no effect,
1 and above determine the blur matrix radius that determine how much to
blur the image.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_sharpen(int radius);</font></font></tt></b>

<blockquote>This sharpens the current image. The radius affects how much
to sharpen by.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_tile_horizontal(void);</font></font></tt></b>

<blockquote>This modifies an image so it will tile seamlessly horizontally
if used as a tile (i.e. drawn multiple times horizontally)</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_tile_vertical(void);</font></font></tt></b>

<blockquote>This modifies an image so it will tile seamlessly vertically
if used as a tile (i.e. drawn multiple times vertically)</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_tile(void);</font></font></tt></b>

<blockquote>This modifies an image so it will tile seamlessly horizontally
and vertically if used as a tile (i.e. drawn multiple times horizontally
and vertically)</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Font imlib_load_font(const char *font_name);</font></font></tt></b>

<blockquote>This function will load a truetype font from the first directory
in the font path that contains that font. The font name format is "font_name/size".
For example. If there is a font file called blum.ttf somewhere in the font
path you might use "blum/20" to load a 20 pixel sized font of blum. If
the font cannot be found NULL is returned.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_font(void);</font></font></tt></b>

<blockquote>This frees the current font.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_text_draw(int x, int y, const char *text);</font></font></tt></b>

<blockquote>Call this function to draw the null-byte terminated string text
using the current font on the current image at the x, y location (x, y
denoting the top left corner of the font string)</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_text_draw_with_return_metrics(int x, 
                                         int y, 
                                         const char *text, 
                                         int *width_return, 
                                         int *height_return, 
                                         int *horizontal_advance_return, 
                                         int *vertical_advance_return);</font></font></tt></b>

<blockquote>This function works just like imlib_text_draw() but also returns
the width and height of the string drawn, and horizontal_advance_return
returns the number of pixels you should advance horizontally to draw another
string (useful if you are drawing a line of text word by word) and vertical_advance_return
does the same for the vertical direction (i.e. drawing text line by line).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_get_text_size(const char *text, 
                         int *width_return, 
                         int *height_return);</font></font></tt></b>

<blockquote>This function returns the width and height in pixels the text
string would use up if drawn with the current font.</blockquote>


<b><tt><font color="#660000"><font size=+2>void imlib_get_text_advance(const char *text,
                            int *horizontal_advance_return,
                            int *vertical_advance_return);</font></font></tt></b>

<blockquote>This function returns the advance horizontally and vertically
in pixels the next text string would need to be placed at for the current
font. The advances are not adjusted for rotation so you will have to translate
the advances (which are calculated as if the text was drawn horizontally
from left to right) depending on the text orientation.</blockquote>


<b><tt><font color="#660000"><font size=+2>int imlib_get_text_inset(const char *text);</font></font></tt></b>

<blockquote>This function returns the inset of the first character of the
text string passed in using the current font and returns that value in pixels.
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_add_path_to_font_path(const char *path);</font></font></tt></b>

<blockquote>This function adds the directory path to the end of the current
list of directories to scan for fonts.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_remove_path_from_font_path(const char *path);</font></font></tt></b>

<blockquote>This function removes all directories in the font path that
match the path specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>char **imlib_list_font_path(int *number_return);</font></font></tt></b>

<blockquote>This returns a list of strings that are the directories in
the font path. Do not free this list or change it in any way. If you add
or delete members of the font path this list will be invalid. If you intend
to use this list later duplicate it for your own use. The number of elements
in the array of strings is put into number_return.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_text_get_index_and_location(const char *text, 
                                      int x, 
                                      int y, 
                                      int *char_x_return, 
                                      int *char_y_return, 
                                      int *char_width_return, 
                                      int *char_height_return);</font></font></tt></b>

<blockquote>This will return the character number in the string text using
the current font at the x, y pixel location which is an offset relative
to the top left of that string. -1 is returned if there is no character
there. If there is a character, character x, y, width and height are also
filled in.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_text_get_location_at_index(const char *text, 
                                      int index, 
                                      int *char_x_return, 
                                      int *char_y_return, 
                                      int *char_width_return, 
                                      int *char_height_return);</font></font></tt></b>

<blockquote>This will return the geometry of the character at index index
in the text string using the current font.</blockquote>

<b><tt><font color="#660000"><font size=+2>char **imlib_list_fonts(int *number_return);</font></font></tt></b>

<blockquote>This returns a list of fonts imlib2 can find in its font path.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_font_list(char **font_list, 
                          int number);</font></font></tt></b>

<blockquote>This will free the font list returned by imlib_list_fonts().</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_font_cache_size(void);</font></font></tt></b>

<blockquote>This returns the font cache size in bytes.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_set_font_cache_size(int bytes);</font></font></tt></b>

<blockquote>This sets the font cache in bytes. Whenever you set the font
cache size Imlib2 will flush fonts from the cache until the memory used
by fonts is less than or equal to the font cache size. Setting the size
to 0 effectively frees all speculatively cached fonts.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_flush_font_cache(void);</font></font></tt></b>

<blockquote>This will cause a flush of all speculatively cached fonts from
the font cache.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_font_ascent(void);</font></font></tt></b>

<blockquote>Returns the current font's ascent value in pixels.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_font_descent(void);</font></font></tt></b>

<blockquote>Returns the current font's descent value in pixels.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_maximum_font_ascent(void);</font></font></tt></b>

<blockquote>Returns the current font's maximum ascent extent.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_get_maximum_font_descent(void);</font></font></tt></b>

<blockquote>Returns the current font's maximum descent extent.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Color_Modifier imlib_create_color_modifier(void);</font></font></tt></b>

<blockquote>This function creates a new empty color modifier and returns
a valid handle on success. NULL is returned on failure.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_color_modifier(void);</font></font></tt></b>

<blockquote>Calling this function frees the current color modifier.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_modify_color_modifier_gamma(double gamma_value);</font></font></tt></b>

<blockquote>This function modifies the current color modifier by adjusting
the gamma by the value specified. The color modifier is modified not set,
so calling this repeatedly has cumulative effects. A gamma of 1.0 is normal
linear, 2.0 brightens and 0.5 darkens etc. Negative values are not allows.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_modify_color_modifier_brightness(double brightness_value);</font></font></tt></b>

<blockquote>This function modifies the current color modifier by adjusting
the brightness by the value specified. The color modifier is modified not
set, so calling this repeatedly has cumulative effects. brightness values
of 0 do not affect anything. -1.0 will make things completely black and
1.0 will make things all white. Values in-between vary brightness linearly.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_modify_color_modifier_contrast(double contrast_value);</font></font></tt></b>

<blockquote>This function modifies the current color modifier by adjusting
the contrast by the value specified. The color modifier is modified not
set, so calling this repeatedly has cumulative effects. Contrast of 1.0
does nothing. 0.0 will merge to gray, 2.0 will double contrast etc.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_set_color_modifier_tables(DATA8 *red_table, 
                                     DATA8 *green_table, 
                                     DATA8 *blue_table, 
                                     DATA8 *alpha_table);</font></font></tt></b>

<blockquote>This function explicitly copies the mapping tables from the
table pointers passed into this function into those of the current color
modifier. Tables are 256 entry arrays of DATA8 which are a mapping of that
channel value to a new channel value. A normal mapping would be linear
(v[0] = 0, v[10] = 10, v[50] = 50, v[200] = 200, v[255] = 255).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_get_color_modifier_tables(DATA8 *red_table, 
                                     DATA8 *green_table, 
                                     DATA8 *blue_table, 
                                     DATA8 *alpha_table);</font></font></tt></b>

<blockquote>This copies the table values from the current color modifier
into the pointers to mapping tables specified. They must have 256 entries
and be DATA8 format.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_reset_color_modifier(void);</font></font></tt></b>

<blockquote>This function resets the current color modifier to have linear
mapping tables.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_apply_color_modifier(void);</font></font></tt></b>

<blockquote>This uses the current color modifier and modifies the current
image using the mapping tables in the current color modifier.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_apply_color_modifier_to_rectangle(int x, 
                                             int y, 
                                             int width, 
                                             int height);</font></font></tt></b>

<blockquote>This works the same way as imlib_apply_color_modifier() but
only modifies a selected rectangle in the current image.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Updates imlib_image_draw_line(int x1, 
                                    int y1, 
                                    int x2, 
                                    int y2, 
                                    char make_updates);</font></font></tt></b>

<blockquote>Draw a line using the current color on the current image from
coordinates x1, y1 to x2, y2. If make_updates is 1 it will also return
an update you can use for an updates list, otherwise it returns NULL.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_draw_rectangle(int x, 
                                int y, 
                                int width, 
                                int height);</font></font></tt></b>

<blockquote>This draws the outline of a rectangle on the current image
at the x, y coordinates with a size of width and height pixels, using the
current color.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_fill_rectangle(int x, 
                                int y, 
                                int width, 
                                int height);</font></font></tt></b>

<blockquote>This draws a filled rectangle on the current image at the x,
y coordinates with a size of width and height pixels, using the current
color.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_copy_alpha_to_image(Imlib_Image image_source, 
                                     int x, 
                                     int y);</font></font></tt></b>

<blockquote>This copies the alpha channel of the source image to the x,
y coordinates of the current image, replacing the alpha channel there.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_copy_alpha_rectangle_to_image(Imlib_Image image_source, 
                                               int x, 
                                               int y, 
                                               int width, 
                                               int height, 
                                               int destination_x, 
                                               int destination_y);</font></font></tt></b>

<blockquote>This copies the source x, y, width, height rectangle alpha
channel from the source image and replaces the alpha channel on the destination
image at the x, y, coordinates.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_scroll_rect(int x, 
                             int y, 
                             int width, 
                             int height, 
                             int delta_x, 
                             int delta_y);</font></font></tt></b>

<blockquote>This scrolls a rectangle at x, y, width, height within the
current image by the delta x, y distance (in pixels).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_copy_rect(int x, 
                           int y, 
                           int width, 
                           int height, 
                           int new_x, 
                           int new_y);</font></font></tt></b>

<blockquote>This copies a rectangle of size width, height at the x, y location
specified in the current image to a new location x, y in the same image.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Color_Range imlib_create_color_range(void);</font></font></tt></b>

<blockquote>This creates a new empty color range and returns a valid handle
to that color range.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_color_range(void);</font></font></tt></b>

<blockquote>This frees the current color range.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_add_color_to_color_range(int distance_away);</font></font></tt></b>

<blockquote>This adds the current color to the current color range at a
distance_away distance from the previous color in the range (if it's the
first color in the range this is irrelevant).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_fill_color_range_rectangle(int x, 
                                            int y, 
                                            int width, 
                                            int height, 
                                            double angle);</font></font></tt></b>

<blockquote>This fills a rectangle of width and height at the x, y location
specified in the current image with a linear gradient of the current color
range at an angle of angle degrees with 0 degrees being vertical from top
to bottom going clockwise from there.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_fill_hsva_color_range_rectangle(int x, 
                                                 int y, 
                                                 int width, 
                                                 int height, 
                                                 double angle);</font></font></tt></b>

<blockquote>This fills a rectangle of width and height at the x, y location
specified in the current image with a linear gradient in HSVA color space of 
the current color range at an angle of angle degrees with 0 degrees being 
vertical from top to bottom going clockwise from there.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_query_pixel(int x, 
                             int y, 
                             Imlib_Color *color_return);</font></font></tt></b>

<blockquote>This fills the color_return color structure with the color
of the pixel in the current image that is at the x, y location specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_query_pixel_cmya(int x, 
                                  int y, 
                                  int *cyan, 
                                  int *magenta, 
                                  int *yellow, 
                                  int *alpha);</font></font></tt></b>

<blockquote>This returns the CMYA color of the pixel in the current image
that is at the x, y location specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_query_pixel_hsva(int x, 
                                  int y, 
                                  float *hue, 
                                  float *saturation, 
                                  float *value, 
                                  int *alpha);</font></font></tt></b>

<blockquote>This returns the HSVA color of the pixel in the current image
that is at the x, y location specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_query_pixel_hlsa(int x, 
                                  int y, 
                                  float *hue, 
                                  float *lightness, 
                                  float *saturation, 
                                  int *alpha);</font></font></tt></b>

<blockquote>This returns the HLSA color of the pixel in the current image
that is at the x, y location specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_attach_data_value(const char *key, 
                                   void *data, 
                                   int value, 
                                   Imlib_Data_Destructor_Function destructor_function);</font></font></tt></b>

<blockquote>This attaches data to the current image with the string key
of key, and the data of data and an integer of value. The destructor function,
if not NULL is called when this image is freed so the destructor can free
the data, if this is needed.</blockquote>

<b><tt><font color="#660000"><font size=+2>void *imlib_image_get_attached_data(const char *key);</font></font></tt></b>

<blockquote>This returns the data attached to the current image with the
key specified. NULL is returned if no data could be found with that key
on the current image.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_image_get_attached_value(const char *key);</font></font></tt></b>

<blockquote>This returns the value attached to the current image with the
specified key. If none could be found 0 is returned.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_remove_attached_data_value(const char *key);</font></font></tt></b>

<blockquote>This detaches the data &amp; value attached with the specified
key from the current image.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_remove_and_free_attached_data_value(const char *key);</font></font></tt></b>

<blockquote>This removes the data and value attached to the current image
with the specified key and also calls the destructor function that was
supplied when attaching it.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_save_image(const char *filename);</font></font></tt></b>

<blockquote>This saves the current image in the format specified by the
current image's format settings to the filename specified.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_save_image_with_error_return(const char *filename, 
                                        Imlib_Load_Error *error_return);</font></font></tt></b>

<blockquote>This works the same way imlib_save_image() works, but will
set the error_return to an error value if the save fails.</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Image imlib_create_rotated_image(double angle);</font></font></tt></b>

<blockquote>This creates an new copy of the current image, but rotated
by angle degrees. On success it returns a valid image handle, otherwise
NULL.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_blend_image_onto_image_at_angle(Imlib_Image source_image, 
                                           char merge_alpha, 
                                           int source_x, 
                                           int source_y, 
                                           int source_width, 
                                           int source_height, 
                                           int destination_x, 
                                           int destination_y, 
                                           int angle_x, 
                                           int angle_y);</font></font></tt></b>

<blockquote>This function works just like imlib_blend_image_onto_image_skewed()
except you cannot skew an image (v_angle_x and v_angle_y are 0).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_blend_image_onto_image_skewed(Imlib_Image source_image, 
                                         char merge_alpha, 
                                         int source_x, 
                                         int source_y, 
                                         int source_width, 
                                         int source_height, 
                                         int destination_x, 
                                         int destination_y, 
                                         int h_angle_x, 
                                         int h_angle_y, 
                                         int v_angle_x, 
                                         int v_angle_y);</font></font></tt></b>

<blockquote>This will blend the source rectangle x, y, width, height from
the source_image onto the current image at the destination x, y location.
<p>It will be rotated and scaled so that the upper right corner will be
positioned h_angle_x pixels to the right (or left, if negative) and h_angle_y
pixels down (from destination_[x|y]).
<p>If v_angle_x and v_angle_y are not 0, the image will also be skewed
so that the lower left corner will be positioned v_angle_x pixels to the
right and v_angle_y pixels down.
<p>The at_angle versions simply have the v_angle_x and v_angle_y set to
0 so the rotation doesn't get skewed, and the render_..._on_drawable ones
seem obvious enough; they do the same on a drawable.
<p>Examples:
<ul>
<li>
imlib_blend_image_onto_image_skewed(..., 0, 0, 100, 0, 0, 100);</li>

<p><br>will simply scale the image to be 100x100.
<br> 
<li>
imlib_blend_image_onto_image_skewed(..., 0, 0, 0, 100, 100, 0);</li>

<p><br>will scale the image to be 100x100, and flip it diagonally.
<br> 
<li>
imlib_blend_image_onto_image_skewed(..., 100, 0, 0, 100, -100, 0);</li>

<p><br>will scale the image and rotate it 90 degrees clockwise.
<br> 
<li>
imlib_blend_image_onto_image_skewed(..., 50, 0, 50, 50, -50, 50);</li>

<p><br>will rotate the image 45 degrees clockwise, and will scale it so
its corners are at (50,0)-(100,50)-(50,100)-(0,50) i.e. it fits into the
100x100 square, so it's scaled down to 70.7% (sqrt(2)/2).
<br> 
<li>
imlib_blend_image_onto_image_skewed(..., 50, 50, 100 * cos(a), 100 * sin(a),
0);</li>

<p><br>will rotate the image `a' degrees, with its upper left corner at
(50,50).
<br> </ul>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_on_drawable_skewed(int source_x, 
                                           int source_y, 
                                           int source_width, 
                                           int source_height, 
                                           int destination_x, 
                                           int destination_y, 
                                           int h_angle_x, 
                                           int h_angle_y, 
                                           int v_angle_x, 
                                           int v_angle_y);</font></font></tt></b>

<blockquote>This works just like imlib_blend_image_onto_image_skewed(),
except it blends the image onto the current drawable instead of the current
image.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_render_image_on_drawable_at_angle(int source_x, 
                                             int source_y, 
                                             int source_width, 
                                             int source_height, 
                                             int destination_x, 
                                             int destination_y, 
                                             int angle_x, 
                                             int angle_y);</font></font></tt></b>

<blockquote>This function works just like imlib_render_image_on_drawable_skewed()
except you cannot skew an image (v_angle_x and v_angle_y are 0).</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_context_set_cliprect(int x, int y, int w, int h);</font></font></tt></b>

<blockquote>Sets the current clipping rectangle to (x,y w*h). The clipping
rectangle effects all image drawing functions and prevents the area outside
the rectangle from being edited. Set w to 0 to disable clipping.</blockquote>

<b><tt><font color="#660000"><font size=+2>int imlib_clip_line(int x0, int y0, int x1, int y1, int xmin, int xmax, int ymin, int ymax, int *clip_x0, int *clip_y0, int *clip_x1, int *clip_y1);</font></font></tt></b>

<blockquote>A utility function to return clipped line coordinates.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_polygon_new(void);</font></font></tt></b>

<blockquote>Returns a new polygon object with no points set.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_polygon_free(ImlibPolygon poly);</font></font></tt></b>

<blockquote>Frees a polygon object.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_polygon_add_point(ImlibPolygon poly, int x, int y);</font></font></tt></b>

<blockquote>Adds the point (x,y) to a polygon object. The point will be
added to the end of the polygon's internal point list. The points are drawn
in order, from the first to the last.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_draw_polygon(ImlibPolygon poly, unsigned char closed);</font></font></tt></b>

<blockquote>Draws a polygon onto the current context image. Points which
have been added to the polygon are drawn in sequence, first to last. The
final point will be joined with the first point if <b>closed</b> is non-zero.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_fill_polygon(ImlibPolygon poly);</font></font></tt></b>

<blockquote>Fill the area defined by the polygon on the current context
image with the current context colour.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_polygon_get_bounds(ImlibPolygon poly, int *px1, int *py1, int *px2, int *py2);</font></font></tt></b>

<blockquote>Calculate the bounding area of the polygon. (px1, py1) defines
the upper left corner of the bounding box and (px2, py2) defines it's lower
right corner.</blockquote>

<b><tt><font color="#660000"><font size=+2>unsigned char imlib_polygon_contains_point(ImlibPolygon poly, int x, int y);</font></font></tt></b>

<blockquote>Returns non-zero if the point (x,y) is within the area defined
by the polygon.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_draw_ellipse(int xc, int yc, int a, int b);</font></font></tt></b>

<blockquote>Draw an ellipse on the current context image. The ellipse is
defined as (x-xc)^2/a^2 + (y-yc)^2/b^2 = 1. This means that the point (<b>xc</b>,<b>yc</b>)
marks the center of the ellipse, <b>a</b> defines the horizontal amplitude
of the ellipse, and <b>b</b> defines the vertical amplitude.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_fill_ellipse(int xc, int yc, int a, int b);</font></font></tt></b>

<blockquote>Fills an ellipse on the current context image using the current
context colour. The ellipse is defined as (x-xc)^2/a^2 + (y-yc)^2/b^2 =
1. This means that the point (<b>xc</b>,<b>yc</b>) marks the center of
the ellipse, <b>a</b> defines the horizontal amplitude of the ellipse,
and <b>b</b> defines the vertical amplitude.</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_image_filter(void);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>Imlib_Filter imlib_create_filter(int initsize);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_free_filter(void);</font></font></tt></b>
<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_set(int xoff, 
                      int yoff, 
                      int a, 
                      int r, 
                      int g, 
                      int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_set_alpha(int xoff, 
                            int yoff, 
                            int a, 
                            int r, 
                            int g, 
                            int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_set_red(int xoff, 
                          int yoff, 
                          int a, 
                          int r, 
                          int g, 
                          int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_set_green(int xoff, 
                            int yoff, 
                            int a, 
                            int r, 
                            int g, 
                            int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_set_blue(int xoff, 
                           int yoff, 
                           int a, 
                           int r, 
                           int g, 
                           int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_constants(int a, 
                            int r, 
                            int g, 
                            int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_filter_divisors(int a, 
                           int r, 
                           int g, 
                           int b);</font></font></tt></b>

<blockquote>
</blockquote>

<b><tt><font color="#660000"><font size=+2>void imlib_apply_filter( char *script, ... );</font></font></tt></b>

<blockquote>
</blockquote>

<p>
<b>Imlib 2 Dynamic Filters</b>
<p>
Imlib2 has built in features allowing filters and effects to be applied at
run time through a very small scripting language, this is similar to that
of script-fu found in the GIMP (http://www.gimp.org). There are two parts
to the system, the client library call ``imlib_apply_filter'' and the
library side filters. The library side filters are synonymous with image
loaders.
<p>
To run a script on an image you need to set the context image then call:
<p>
<blockquote>
<pre>
imlib_apply_filter( script_string, ... );
</pre>
</blockquote>
<p>
The script_string variable is made up of the script language, which is
very simple and made up of only function calls. Functions calls look like
this:
<p>   
<blockquote>
<pre>
filter name( key=value [, ...] );
</pre>
</blockquote>
<p>
Where,
<p>
<blockquote>
<b>filter name</b> is the name of the filter you wish to apply<br>
<b>key</b> is an expected value<br>
<b>value</b> is a ``string'', a number, or an actual variable in<br>
</blockquote>
<p>
the program, or the result of another filter.
<p>
eg.
<p>
<blockquote>
<pre>
bump_map( map=tint(red=50,tint=200), blue=10 );
</pre>
</blockquote>
<p>
This example would bump map using a a map generated from the tint filter.
<p>
It is also possible to pass application information to the filters via the
usage of the [] operator. When the script is being compiled the script
engine looks on the parameters passed to it and picks up a pointer for
every [] found.
<p>
eg2.
<p>
<blockquote>
<pre>
imlib_apply_filter( "tint( x=[], y=[], red=255, alpha=55 );", &myxint, &myyint );
</pre>
</blockquote>
<p>
This will cause a tint to the current image at (myxint,myyint) to be
done. This is very useful for when you want the filters to dynamically
change according to program variables.
The system is very quick as the code is pseudo-compiled and then run. The
advantage of having the scripting system allows customization of the image
manipulations, this is particularly useful in applications that allow
modifications to be done (eg. image viewers).
<p>
<b>Filter Library</b>
<p>
There are three functions that must be in every filter library
<p>
<blockquote>
<pre>
void init( struct imlib_filter_info *info ); - Called once on loading of the filter
</pre>
</blockquote>
<p>  
info - a structure passed to the filter to be filled in with information about the filter
info-&gt;name - Name of the filter library<br>
info-&gt;author - Name of the library author<br>
info-&gt;description - Description of the filter library<br>
info-&gt;num_filters - Number of filters the library exports<br>
info-&gt;filters - An array of ``char *'' with each filter name in it.<br>
<p>      
<blockquote>
<pre>
void deinit(); - Called when the filter is closed
</pre>
</blockquote>
<p>	
<blockquote>
<pre>
/* Called every time a filter the library exports is called */
void *exec( char *filter, void *im, pIFunctionParam params );
</pre>
</blockquote>
<p>	  
filter - The name of the filter being asked for
im - The image that the filter should be applied against
params - A linked list of parameters.
<p>		      
The best way to get all the values is such:
<blockquote>
Declare all parameters and initialize them to there default values.
<blockquote>
<pre>
  for( ptr = params; ptr != NULL; ptr = ptr-&gt;next )
    {
      ..MACRO TO GET VALUE..
    }
</pre>
</blockquote>				  
Current Macros are:
<blockquote>
<pre>
   ASSIGN_INT( keyname, local variable )
   ASSIGN_DATA8( keyname, local variable )
   ASSIGN_IMAGE( keyname, local variable )
</pre>
</blockquote>		
eg.
<blockquote>
<pre>
   int r = 50;
   IFunctionParam *ptr;
				      
   for( ptr = params; ptr != NULL; ptr = ptr-&gt;next )
     {
       ASSIGN_INT( "red", r );
     }
</pre>     
</blockquote>
</blockquote>
<p>
If the value "red" is not passed to the filter then it will remain
at 50, but it a value is passed, it will be assign to r.
<p>
return type - Imlib_Image, this is the result of filter.
<p>

</td>

<td><img SRC="img/blank.gif" height=1 width=1></td>
</tr>

<tr>
<td WIDTH="1"><img SRC="img/blank.gif" height=1 width=1></td>

<td><img SRC="img/blank.gif" height=1 width=1></td>

<td WIDTH="1"><img SRC="img/blank.gif" height=1 width=1></td>
</tr>
</table></center>

</body></html>


