// qobject.sip generated by MetaSIP on Fri Apr 16 11:32:08 2010
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QWidget /External/;
typedef QList<QObject*> QObjectList;

class QObject /Supertype=sip.wrapper/
{

%TypeHeaderCode
#include <qobject.h>
%End

%TypeCode
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the recursive helper functions for QObject::findChild() and
// QObject::findChildren.

static PyObject *qtcore_FindChild(const QObject *parent, PyTypeObject *type, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    PyObject *clist = PyList_New(children.size());

    if (!clist)
        return 0;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
        {
            Py_DECREF(clist);
            return 0;
        }

        if ((name.isNull() || obj->objectName() == name) && PyType_IsSubtype(Py_TYPE(pyo), type))
        {
            Py_DECREF(clist);
            return pyo;
        }

        PyList_SET_ITEM(clist, i, pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_FindChild(children.at(i), type, name);

        if (pyo != Py_None)
        {
            Py_DECREF(clist);
            return pyo;
        }

        Py_DECREF(pyo);
    }

    Py_DECREF(clist);

    Py_INCREF(Py_None);
    return Py_None;
}

static int qtcore_FindChildren(const QObject *parent, PyTypeObject *type, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return -1;

        if ((name.isNull() || obj->objectName() == name) && PyType_IsSubtype(Py_TYPE(pyo), type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        int rc = qtcore_FindChildren(obj, type, name, list);

        Py_DECREF(pyo);

        if (rc < 0)
            return -1;
    }

    return 0;
}

static int qtcore_FindChildren(const QObject *parent, PyTypeObject *type, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return -1;

        if (re.indexIn(obj->objectName()) >= 0 && PyType_IsSubtype(Py_TYPE(pyo), type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        int rc = qtcore_FindChildren(obj, type, re, list);

        Py_DECREF(pyo);

        if (rc < 0)
            return -1;
    }

    return 0;
}
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
    #if QT_VERSION >= 0x040400
        {sipName_QSharedMemory, &sipType_QSharedMemory, -1, 1},
    #else
        {0, 0, -1, 1},
    #endif
        {sipName_QObjectCleanupHandler, &sipType_QObjectCleanupHandler, -1, 2},
        {sipName_QMimeData, &sipType_QMimeData, -1, 3},
        {sipName_QSettings, &sipType_QSettings, -1, 4},
        {sipName_QAbstractEventDispatcher, &sipType_QAbstractEventDispatcher, -1, 5},
    #if QT_VERSION >= 0x040400
        {sipName_QThreadPool, &sipType_QThreadPool, -1, 6},
    #else
        {0, 0, -1, 6},
    #endif
        {sipName_QSocketNotifier, &sipType_QSocketNotifier, -1, 7},
        {sipName_QTimer, &sipType_QTimer, -1, 8},
        {sipName_QPluginLoader, &sipType_QPluginLoader, -1, 9},
        {sipName_QSignalMapper, &sipType_QSignalMapper, -1, 10},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractState, &sipType_QAbstractState, 22, 11},
    #else
        {0, 0, 22, 11},
    #endif
        {sipName_QIODevice, &sipType_QIODevice, 26, 12},
        {sipName_QTranslator, &sipType_QTranslator, -1, 13},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractTransition, &sipType_QAbstractTransition, 30, 14},
    #else
        {0, 0, 30, 14},
    #endif
        {sipName_QCoreApplication, &sipType_QCoreApplication, -1, 15},
    #if QT_VERSION >= 0x040200
        {sipName_QTimeLine, &sipType_QTimeLine, -1, 16},
    #else
        {0, 0, -1, 16},
    #endif
        {sipName_QAbstractItemModel, &sipType_QAbstractItemModel, 32, 17},
    #if QT_VERSION >= 0x040600
        {sipName_QAbstractAnimation, &sipType_QAbstractAnimation, 34, 18},
    #else
        {0, 0, 34, 18},
    #endif
        {sipName_QEventLoop, &sipType_QEventLoop, -1, 19},
    #if QT_VERSION >= 0x040200
        {sipName_QFileSystemWatcher, &sipType_QFileSystemWatcher, -1, 20},
    #else
        {0, 0, -1, 20},
    #endif
        {sipName_QLibrary, &sipType_QLibrary, -1, 21},
        {sipName_QThread, &sipType_QThread, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QState, &sipType_QState, 25, 23},
        {sipName_QFinalState, &sipType_QFinalState, -1, 24},
        {sipName_QHistoryState, &sipType_QHistoryState, -1, -1},
        {sipName_QStateMachine, &sipType_QStateMachine, -1, -1},
    #else
        {0, 0, 25, 23},
        {0, 0, -1, 24},
        {0, 0, -1, -1},
        {0, 0, -1, -1},
    #endif
        {sipName_QBuffer, &sipType_QBuffer, -1, 27},
        {sipName_QFile, &sipType_QFile, 29, 28},
        {sipName_QProcess, &sipType_QProcess, -1, -1},
        {sipName_QTemporaryFile, &sipType_QTemporaryFile, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QEventTransition, &sipType_QEventTransition, -1, 31},
        {sipName_QSignalTransition, &sipType_QSignalTransition, -1, -1},
    #else
        {0, 0, -1, 31},
        {0, 0, -1, -1},
    #endif
        {sipName_QAbstractListModel, &sipType_QAbstractListModel, -1, 33},
        {sipName_QAbstractTableModel, &sipType_QAbstractTableModel, -1, -1},
    #if QT_VERSION >= 0x040600
        {sipName_QAnimationGroup, &sipType_QAnimationGroup, 37, 35},
        {sipName_QVariantAnimation, &sipType_QVariantAnimation, 39, 36},
        {sipName_QPauseAnimation, &sipType_QPauseAnimation, -1, -1},
        {sipName_QSequentialAnimationGroup, &sipType_QSequentialAnimationGroup, -1, 38},
        {sipName_QParallelAnimationGroup, &sipType_QParallelAnimationGroup, -1, -1},
        {sipName_QPropertyAnimation, &sipType_QPropertyAnimation, -1, -1},
    #else
        {0, 0, 37, 35},
        {0, 0, 39, 36},
        {0, 0, -1, -1},
        {0, 0, -1, 38},
        {0, 0, -1, -1},
        {0, 0, -1, -1},
    #endif
    };
    
    int i = 0;
    
    sipType = 0;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
    static const QMetaObject staticMetaObject;
%GetCode
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
%End

    const QMetaObject *metaObject() const;
    explicit QObject(QObject *parent /TransferThis/ = 0);
    virtual ~QObject();
    void pyqtConfigure(SIP_PYOBJECT) /NoArgParser/;
%Docstring
QObject.pyqtConfigure(...)

Each keyword argument is either the name of a Qt property or a Qt signal.
For properties the property is set to the given value which should be of an
appropriate type.
For signals the signal is connected to the given value which should be a
callable.
%End

%MethodCode
        // Check there are no positional arguments.
        if (PyTuple_Size(sipArgs) > 0)
        {
            PyErr_SetString(PyExc_TypeError, "QObject.pyqtConfigure() has no positional arguments");
            return 0;
        }
        
        // Get the QObject self.
        void *qobj = sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QObject);
        
        if (!qobj)
            return 0;
        
        // Configure it and raise an exception if any aren't known.
        if (qpycore_pyqtconfigure(sipSelf, reinterpret_cast<QObject *>(qobj), sipKwds) < 0)
            return 0;
        
        Py_INCREF(Py_None);
        return Py_None;
%End

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
%If (Qt_4_2_0 -)
    QString tr(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, int n = -1) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::CodecForTr);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::CodecForTr, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%If (- Qt_4_2_0)
    QString tr(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::DefaultCodec);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::DefaultCodec));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsLatin1String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromLatin1(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
%If (Qt_4_2_0 -)
    QString trUtf8(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0, int n = -1) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::UnicodeUTF8, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%If (- Qt_4_2_0)
    QString trUtf8(SIP_PYOBJECT sourceText /DocType="str"/, const char *disambiguation = 0) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::UnicodeUTF8));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsUTF8String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromUtf8(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
    SIP_PYOBJECT findChild(SIP_PYTYPE type, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="QObject"/;
%MethodCode
        sipRes = qtcore_FindChild(sipCpp, (PyTypeObject *)a0, *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QString &name /DocValue="Py_v3:''"/ = QString()) const /DocType="list-of-QObject"/;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QRegExp &regExp) const /DocType="list-of-QObject"/;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    void emit(SIP_SIGNAL, ...) const;
%MethodCode
        if (!qpycore_qobject_emit(sipCpp, a0, a1))
            sipIsErr = 1;
%End

    QString objectName() const;
    void setObjectName(const QString &);
    bool isWidgetType() const;
    bool signalsBlocked() const;
    bool blockSignals(bool);
    QThread *thread() const;
    void moveToThread(QThread *);
    int startTimer(int);
    void killTimer(int);
    const QObjectList &children() const;
    void setParent(QObject * /TransferThis/);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);
    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, a3, (int)a4);
%End

    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE, Qt::ConnectionType=Qt::AutoConnection) /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, 0, (int)a3);
%End

    SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) const /DocType="bool"/;
%MethodCode
        sipRes = sipConnectRx(a0, a1, sipSelf, a2, (int)a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT) /DocType="bool"/;
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE) /DocType="bool"/;
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, 0);
%End

    void dumpObjectInfo();
    void dumpObjectTree();
%If (Qt_4_2_0 -)
    QList<QByteArray> dynamicPropertyNames() const;
%End
    bool setProperty(const char *, const QVariant &);
    QVariant property(const char *) const;

signals:
    void destroyed(QObject *object = 0);

public:
    QObject *parent() const;
    bool inherits(const char *) const;

public slots:
    void deleteLater() /TransferThis/;

public:
    QObject *sender() const;
%MethodCode
        // This is actually protected but we never need to call the real method.
        
        sipRes = qpycore_qobject_sender();
%End

protected:
    int receivers(SIP_SIGNAL) const;
%MethodCode
        // We need to take into account any proxies for Python signals. Import the
        // helper if it hasn't already been done.
        typedef int (*helper_func)(QObject *, const char *, int);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_receivers");
        
        if (helper)
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            sipRes = helper(sipCpp, a0, sipCpp->receivers(a0));
        #else
            sipRes = helper(sipCpp, a0, sipCpp->sipProtect_receivers(a0));
        #endif
%End

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);
    virtual void connectNotify(SIP_SIGNAL);
    virtual void disconnectNotify(SIP_SIGNAL);

private:
    QObject(const QObject &);
};

SIP_PYOBJECT Q_ENUMS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT Q_FLAGS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TR_NOOP_UTF8(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT /DocType="str"/, SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a1);
    sipRes = a1;
%End

SIP_PYOBJECT SLOT(const char * /Encoding="ASCII"/) /DocType="str"/;
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('1');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT SIGNAL(const char * /Encoding="ASCII"/) /DocType="str"/;
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('2');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT pyqtSlot(const char *signature, const char *name = 0, const char *result = 0) /NoArgParser/;
%Docstring
@pyqtSlot(*types, str name=None, str result=None)

This is a decorator applied to Python methods of a QObject that marks them
as Qt slots.
The non-keyword arguments are the types of the slot arguments and each may
be a Python type object or a string specifying a C++ type.
name is the name of the slot and defaults to the name of the method.
result is type of the value returned by the slot.
%End

%MethodCode
    return qpycore_pyqtslot(sipArgs, sipKwds);
%End

SIP_PYOBJECT pyqtSignature(const char *signature, const char *result = 0) /NoArgParser/;
%Docstring
@pyqtSignature(str signature,  str result=None)

This is deprecated, use pyqtSlot() instead.

This is a decorator applied to Python methods of a QObject that marks them
as Qt slots.
signature is a string specifying the C++ signature of the slot.
result is type of the value returned by the slot.
%End

%MethodCode
    return qpycore_pyqtsignature(sipArgs, sipKwds);
%End

%ModuleHeaderCode
#include <qpycore_api.h>
%End

%ModuleCode
// These optional parts of the legacy Qt support API for SIP are implemented.
// This cannot go into qpycore_api.h as they need to be in a particular
// position in the generated code.

#undef sipQtCreateUniversalSignal
#undef sipQtFindUniversalSignal

extern "C"
{
    void *sipQtCreateUniversalSignal(void *tx, const char **sig);
    void *sipQtFindUniversalSignal(void *tx, const char **sig);
    void *sipQtCreateUniversalSlot(sipWrapper *tx, const char *sig,
            PyObject *rxObj, const char *slot, const char **member, int flags);
    void sipQtDestroyUniversalSlot(void *rx);
    void *sipQtFindSlot(void *tx, const char *sig, PyObject *rxObj,
            const char *slot, const char **member);
    int sipQtConnect(void *tx, const char *sig, void *rx, const char *slot,
            int type);
    int sipQtDisconnect(void *tx, const char *sig, void *rx, const char *slot);
    int sipQtSameSignalSlotName(const char *s1, const char *s2);
    sipSlot *sipQtFindSipslot(void *tx, void **context);
}
%End

%InitialisationCode
qpycore_init();
%End

%PostInitialisationCode
qpycore_post_init(sipModuleDict);
%End
