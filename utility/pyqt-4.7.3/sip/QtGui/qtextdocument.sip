// qtextdocument.sip generated by MetaSIP on Fri Apr 16 11:32:08 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qtextdocument.h>
%End

namespace Qt
{
%TypeHeaderCode
#include <qtextdocument.h>
%End

    enum HitTestAccuracy
    {
        ExactHit,
        FuzzyHit,
    };

    enum WhiteSpaceMode
    {
        WhiteSpaceNormal,
        WhiteSpacePre,
        WhiteSpaceNoWrap,
        WhiteSpaceModeUndefined,
    };

    bool mightBeRichText(const QString &);
    QString escape(const QString &);
    QString convertFromPlainText(const QString &, Qt::WhiteSpaceMode mode = Qt::WhiteSpacePre);
};

class QTextDocument : QObject
{

%TypeHeaderCode
#include <qtextdocument.h>
%End

public:
    explicit QTextDocument(QObject *parent /TransferThis/ = 0);
    QTextDocument(const QString &, QObject *parent /TransferThis/ = 0);
    virtual ~QTextDocument();
    QTextDocument *clone(QObject *parent /TransferThis/ = 0) const /Factory/;
    bool isEmpty() const;
    virtual void clear();
    void setUndoRedoEnabled(bool);
    bool isUndoRedoEnabled() const;
    bool isUndoAvailable() const;
    bool isRedoAvailable() const;
    void setDocumentLayout(QAbstractTextDocumentLayout * /Transfer/);
    QAbstractTextDocumentLayout *documentLayout() const;

    enum MetaInformation
    {
        DocumentTitle,
%If (Qt_4_4_0 -)
        DocumentUrl,
%End
    };

    void setMetaInformation(QTextDocument::MetaInformation, const QString &);
    QString metaInformation(QTextDocument::MetaInformation) const;
    QString toHtml(const QByteArray &encoding = QByteArray()) const;
    void setHtml(const QString &);
    QString toPlainText() const;
    void setPlainText(const QString &);

    enum FindFlag
    {
        FindBackward,
        FindCaseSensitively,
        FindWholeWords,
    };

    typedef QFlags<QTextDocument::FindFlag> FindFlags;
    QTextCursor find(const QString &, int position = 0, QFlags<QTextDocument::FindFlag> options = 0) const;
%If (Qt_4_2_0 -)
    QTextCursor find(const QRegExp &, int position = 0, QFlags<QTextDocument::FindFlag> options = 0) const;
%End
    QTextCursor find(const QString &, const QTextCursor &, QFlags<QTextDocument::FindFlag> options = 0) const;
%If (Qt_4_2_0 -)
    QTextCursor find(const QRegExp &, const QTextCursor &, QFlags<QTextDocument::FindFlag> options = 0) const;
%End
    QTextFrame *rootFrame() const;
    QTextObject *object(int) const;
    QTextObject *objectForFormat(const QTextFormat &) const;
    QTextBlock findBlock(int) const;
    QTextBlock begin() const;
    QTextBlock end() const;
    void setPageSize(const QSizeF &);
    QSizeF pageSize() const;
    void setDefaultFont(const QFont &);
    QFont defaultFont() const;
    int pageCount() const;
    bool isModified() const;
%If (PyQt_Printer)
    void print(QPrinter *) const /PyName=print_/;
%End
%If (Py_v3 || PyQt_Printer)
    void print(QPrinter *printer) const;
%End

    enum ResourceType
    {
        HtmlResource,
        ImageResource,
%If (Qt_4_2_0 -)
        StyleSheetResource,
%End
        UserResource,
    };

    QVariant resource(int, const QUrl &) const;
    void addResource(int, const QUrl &, const QVariant &);
    QVector<QTextFormat> allFormats() const;
    void markContentsDirty(int, int);
    void setUseDesignMetrics(bool);
    bool useDesignMetrics() const;

signals:
%If (Qt_4_3_0 -)
    void blockCountChanged(int);
%End
    void contentsChange(int, int, int);
    void contentsChanged();
    void cursorPositionChanged(const QTextCursor &);
    void modificationChanged(bool);
    void redoAvailable(bool);
    void undoAvailable(bool);

public slots:
    void undo();
    void redo();
    void setModified(bool on = true);

protected:
    virtual QTextObject *createObject(const QTextFormat &) /Factory/;
    virtual QVariant loadResource(int, const QUrl &);

public:
%If (Qt_4_2_0 -)
    void drawContents(QPainter *, const QRectF &rect = QRectF());
%End
%If (Qt_4_2_0 -)
    void setTextWidth(qreal);
%End
%If (Qt_4_2_0 -)
    qreal textWidth() const;
%End
%If (Qt_4_2_0 -)
    qreal idealWidth() const;
%End
%If (Qt_4_2_0 -)
    void adjustSize();
%End
%If (Qt_4_2_0 -)
    QSizeF size() const;
%End
%If (Qt_4_2_0 -)
    int blockCount() const;
%End
%If (Qt_4_2_0 -)
    void setDefaultStyleSheet(const QString &);
%End
%If (Qt_4_2_0 -)
    QString defaultStyleSheet() const;
%End
%If (Qt_4_2_0 -)
    void undo(QTextCursor *);
%End
%If (Qt_4_2_0 -)
    void redo(QTextCursor *);
%End
%If (Qt_4_2_0 -)
    int maximumBlockCount() const;
%End
%If (Qt_4_2_0 -)
    void setMaximumBlockCount(int);
%End
%If (Qt_4_3_0 -)
    QTextOption defaultTextOption() const;
%End
%If (Qt_4_3_0 -)
    void setDefaultTextOption(const QTextOption &);
%End
%If (Qt_4_4_0 -)
    int revision() const;
%End
%If (Qt_4_4_0 -)
    QTextBlock findBlockByNumber(int) const;
%End
%If (Qt_4_5_0 -)
    QTextBlock findBlockByLineNumber(int) const;
%End
%If (Qt_4_4_0 -)
    QTextBlock firstBlock() const;
%End
%If (Qt_4_4_0 -)
    QTextBlock lastBlock() const;
%End
%If (Qt_4_4_0 -)
    qreal indentWidth() const;
%End
%If (Qt_4_4_0 -)
    void setIndentWidth(qreal);
%End

signals:
%If (Qt_4_4_0 -)
    void undoCommandAdded();
%End
%If (Qt_4_4_0 -)
    void documentLayoutChanged();
%End

public:
%If (Qt_4_5_0 -)
    QChar characterAt(int) const;
%End
%If (Qt_4_5_0 -)
    qreal documentMargin() const;
%End
%If (Qt_4_5_0 -)
    void setDocumentMargin(qreal);
%End
%If (Qt_4_5_0 -)
    int lineCount() const;
%End
%If (Qt_4_5_0 -)
    int characterCount() const;
%End
%If (Qt_4_6_0 -)
    int availableUndoSteps() const;
%End
%If (Qt_4_6_0 -)
    int availableRedoSteps() const;
%End

private:
    QTextDocument(const QTextDocument &);
};

QFlags<QTextDocument::FindFlag> operator|(QTextDocument::FindFlag, QFlags<QTextDocument::FindFlag>);
