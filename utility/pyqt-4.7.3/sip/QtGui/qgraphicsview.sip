// qgraphicsview.sip generated by MetaSIP on Fri Apr 16 11:32:08 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_2_0 -)
%ModuleCode
#include <qgraphicsview.h>
%End
%End

%If (Qt_4_2_0 -)

class QGraphicsView : QAbstractScrollArea
{

%TypeHeaderCode
#include <qgraphicsview.h>
%End

public:
    enum CacheModeFlag
    {
        CacheNone,
        CacheBackground,
    };

    typedef QFlags<QGraphicsView::CacheModeFlag> CacheMode;

    enum DragMode
    {
        NoDrag,
        ScrollHandDrag,
        RubberBandDrag,
    };

    enum ViewportAnchor
    {
        NoAnchor,
        AnchorViewCenter,
        AnchorUnderMouse,
    };

    QGraphicsView(QWidget *parent /TransferThis/ = 0);
    QGraphicsView(QGraphicsScene * /KeepReference/, QWidget *parent /TransferThis/ = 0);
    virtual ~QGraphicsView();
    virtual QSize sizeHint() const;
    QFlags<QPainter::RenderHint> renderHints() const;
    void setRenderHint(QPainter::RenderHint, bool on = true);
    void setRenderHints(QFlags<QPainter::RenderHint>);
    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment);
    QGraphicsView::ViewportAnchor transformationAnchor() const;
    void setTransformationAnchor(QGraphicsView::ViewportAnchor);
    QGraphicsView::ViewportAnchor resizeAnchor() const;
    void setResizeAnchor(QGraphicsView::ViewportAnchor);
    QGraphicsView::DragMode dragMode() const;
    void setDragMode(QGraphicsView::DragMode);
    QFlags<QGraphicsView::CacheModeFlag> cacheMode() const;
    void setCacheMode(QFlags<QGraphicsView::CacheModeFlag>);
    void resetCachedContent();
    bool isInteractive() const;
    void setInteractive(bool);
    QGraphicsScene *scene() const;
    void setScene(QGraphicsScene * /KeepReference/);
    QRectF sceneRect() const;
    void setSceneRect(const QRectF &);
    QMatrix matrix() const;
    void setMatrix(const QMatrix &, bool combine = false);
    void resetMatrix();
    void rotate(qreal);
    void scale(qreal, qreal);
    void shear(qreal, qreal);
    void translate(qreal, qreal);
    void centerOn(const QPointF &);
    void centerOn(const QGraphicsItem *);
    void ensureVisible(const QRectF &, int xMargin = 50, int yMargin = 50);
    void ensureVisible(const QGraphicsItem *, int xMargin = 50, int yMargin = 50);
    void fitInView(const QRectF &, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    void fitInView(const QGraphicsItem *, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    void render(QPainter *, const QRectF &target = QRectF(), const QRect &source = QRect(), Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    QList<QGraphicsItem*> items() const;
    QList<QGraphicsItem*> items(const QPoint &) const;
    QList<QGraphicsItem*> items(int, int) const;
%If (Qt_4_3_0 -)
    QList<QGraphicsItem*> items(int, int, int, int, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
    QList<QGraphicsItem*> items(const QRect &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPolygon &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPainterPath &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QGraphicsItem *itemAt(const QPoint &) const;
    QPointF mapToScene(const QPoint &) const;
    QPolygonF mapToScene(const QRect &) const;
    QPolygonF mapToScene(const QPolygon &) const;
    QPainterPath mapToScene(const QPainterPath &) const;
    QPoint mapFromScene(const QPointF &) const;
    QPolygon mapFromScene(const QRectF &) const;
    QPolygon mapFromScene(const QPolygonF &) const;
    QPainterPath mapFromScene(const QPainterPath &) const;
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;
    QBrush backgroundBrush() const;
    void setBackgroundBrush(const QBrush &);
    QBrush foregroundBrush() const;
    void setForegroundBrush(const QBrush &);

public slots:
%If (Qt_4_3_0 -)
    void invalidateScene(const QRectF &rect = QRectF(), QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
    void updateScene(const QList<QRectF> &);
    void updateSceneRect(const QRectF &);

protected slots:
    void setupViewport(QWidget *);

protected:
    virtual bool event(QEvent *);
    virtual bool viewportEvent(QEvent *);
    virtual void contextMenuEvent(QContextMenuEvent *);
    virtual void dragEnterEvent(QDragEnterEvent *);
    virtual void dragLeaveEvent(QDragLeaveEvent *);
    virtual void dragMoveEvent(QDragMoveEvent *);
    virtual void dropEvent(QDropEvent *);
    virtual void focusInEvent(QFocusEvent *);
    virtual void focusOutEvent(QFocusEvent *);
%If (Qt_4_4_0 -)
    virtual bool focusNextPrevChild(bool);
%End
    virtual void keyPressEvent(QKeyEvent *);
    virtual void keyReleaseEvent(QKeyEvent *);
    virtual void mouseDoubleClickEvent(QMouseEvent *);
    virtual void mousePressEvent(QMouseEvent *);
    virtual void mouseMoveEvent(QMouseEvent *);
    virtual void mouseReleaseEvent(QMouseEvent *);
    virtual void wheelEvent(QWheelEvent *);
    virtual void paintEvent(QPaintEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void scrollContentsBy(int, int);
    virtual void showEvent(QShowEvent *);
    virtual void inputMethodEvent(QInputMethodEvent *);
    virtual void drawBackground(QPainter *, const QRectF &);
    virtual void drawForeground(QPainter *, const QRectF &);
    virtual void drawItems(QPainter *painter, SIP_PYLIST items /DocType="list-of-QGraphicsItem"/, SIP_PYLIST options /DocType="list-of-QStyleOptionGraphicsItem"/) [void (QPainter *painter, int numItems, QGraphicsItem **items, const QStyleOptionGraphicsItem *options)];
%MethodCode
        // PyQt takes lists as the items and options arguments.
        
        // Adjust the number items according to the actual list lengths.
        SIP_SSIZE_T numItems = PyList_GET_SIZE(a1);
        
        if (numItems > PyList_GET_SIZE(a2))
            numItems = PyList_GET_SIZE(a2);
        
        // Allocate temporary storage for the C++ conversions.
        QGraphicsItem **items = new QGraphicsItem *[numItems];
        QStyleOptionGraphicsItem *options = new QStyleOptionGraphicsItem[numItems];
        
        for (int i = 0; i < numItems; ++i)
        {
            void *cpp;
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a1, i), sipType_QGraphicsItem, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
            items[i] = reinterpret_cast<QGraphicsItem *>(cpp);
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a2, i), sipType_QStyleOptionGraphicsItem, NULL, SIP_NOT_NONE|SIP_NO_CONVERTORS, NULL, &sipIsErr);
            options[i] = *reinterpret_cast<QStyleOptionGraphicsItem *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            if (sipSelfWasArg)
                sipCpp->QGraphicsView::drawItems(a0, numItems, items, options);
            else
                sipCpp->drawItems(a0, numItems, items, options);
        #else
            sipCpp->sipProtectVirt_drawItems(sipSelfWasArg, a0, numItems, items, options);
        #endif
            Py_END_ALLOW_THREADS
        }
        
        delete[] items;
        delete[] options;
%End

%VirtualCatcherCode
        // PyQt handles the items and options arguments as lists, but keeps the
        // numItems argument.
        PyObject *items = PyList_New(a1);
        PyObject *options = PyList_New(a1);
        
        sipIsErr = (!items || !options);
        
        if (!sipIsErr)
            for (int i = 0; i < a1; ++i)
            {
                PyObject *obj;
        
                obj = sipConvertFromType(a2[i], sipType_QGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(items, i, obj);
        
                obj = sipConvertFromType(const_cast<QStyleOptionGraphicsItem *>(&a3[i]), sipType_QStyleOptionGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(options, i, obj);
            }
        
        if (!sipIsErr)
        {
            PyObject *res = sipCallMethod(&sipIsErr, sipMethod, "DSS", a0, sipType_QPainter, NULL, items, options, NULL);
        
            if (res)
            {
                sipParseResult(&sipIsErr, sipMethod, res, "Z");
                Py_DECREF(res);
            }
        }
        
        Py_XDECREF(items);
        Py_XDECREF(options);
%End

public:
    void setSceneRect(qreal, qreal, qreal, qreal);
    void centerOn(qreal, qreal);
    void ensureVisible(qreal, qreal, qreal, qreal, int xMargin = 50, int yMargin = 50);
    void fitInView(qreal, qreal, qreal, qreal, Qt::AspectRatioMode mode = Qt::IgnoreAspectRatio);
    QGraphicsItem *itemAt(int, int) const;
    QPointF mapToScene(int, int) const;
    QPolygonF mapToScene(int, int, int, int) const;
    QPoint mapFromScene(qreal, qreal) const;
    QPolygon mapFromScene(qreal, qreal, qreal, qreal) const;
%If (Qt_4_3_0 -)

    enum ViewportUpdateMode
    {
        FullViewportUpdate,
        MinimalViewportUpdate,
        SmartViewportUpdate,
%If (Qt_4_4_0 -)
        BoundingRectViewportUpdate,
%End
        NoViewportUpdate,
    };

%End
%If (Qt_4_3_0 -)

    enum OptimizationFlag
    {
        DontClipPainter,
        DontSavePainterState,
        DontAdjustForAntialiasing,
    };

%End
%If (Qt_4_3_0 -)
    typedef QFlags<QGraphicsView::OptimizationFlag> OptimizationFlags;
%End
%If (Qt_4_3_0 -)
    QGraphicsView::ViewportUpdateMode viewportUpdateMode() const;
%End
%If (Qt_4_3_0 -)
    void setViewportUpdateMode(QGraphicsView::ViewportUpdateMode);
%End
%If (Qt_4_3_0 -)
    QFlags<QGraphicsView::OptimizationFlag> optimizationFlags() const;
%End
%If (Qt_4_3_0 -)
    void setOptimizationFlag(QGraphicsView::OptimizationFlag, bool enabled = true);
%End
%If (Qt_4_3_0 -)
    void setOptimizationFlags(QFlags<QGraphicsView::OptimizationFlag>);
%End
%If (Qt_4_3_0 -)
    Qt::ItemSelectionMode rubberBandSelectionMode() const;
%End
%If (Qt_4_3_0 -)
    void setRubberBandSelectionMode(Qt::ItemSelectionMode);
%End
%If (Qt_4_3_0 -)
    QTransform transform() const;
%End
%If (Qt_4_3_0 -)
    QTransform viewportTransform() const;
%End
%If (Qt_4_3_0 -)
    void setTransform(const QTransform &, bool combine = false);
%End
%If (Qt_4_3_0 -)
    void resetTransform();
%End
%If (Qt_4_6_0 -)
    bool isTransformed() const;
%End

private:
%If (Qt_4_4_0 -)
    QGraphicsView(const QGraphicsView &);
%End
};

%End
%If (Qt_4_2_0 -)
QFlags<QGraphicsView::CacheModeFlag> operator|(QGraphicsView::CacheModeFlag, QFlags<QGraphicsView::CacheModeFlag>);
%End
%If (Qt_4_3_0 -)
QFlags<QGraphicsView::OptimizationFlag> operator|(QGraphicsView::OptimizationFlag, QFlags<QGraphicsView::OptimizationFlag>);
%End
