// qgl.sip generated by MetaSIP on Fri Apr 16 11:32:08 2010
//
// This file is part of the QtOpenGL Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qgl.h>
%End

%Include opengl_types.sip

namespace QGL
{
%TypeHeaderCode
#include <qgl.h>
%End

    enum FormatOption
    {
        DoubleBuffer,
        DepthBuffer,
        Rgba,
        AlphaChannel,
        AccumBuffer,
        StencilBuffer,
        StereoBuffers,
        DirectRendering,
        HasOverlay,
        SampleBuffers,
        SingleBuffer,
        NoDepthBuffer,
        ColorIndex,
        NoAlphaChannel,
        NoAccumBuffer,
        NoStencilBuffer,
        NoStereoBuffers,
        IndirectRendering,
        NoOverlay,
        NoSampleBuffers,
    };

    typedef QFlags<QGL::FormatOption> FormatOptions;
%If (Qt_4_6_0 -)
    void setPreferredPaintEngine(QPaintEngine::Type);
%End
};

QFlags<QGL::FormatOption> operator|(QGL::FormatOption, QFlags<QGL::FormatOption>);

class QGLFormat
{

%TypeHeaderCode
#include <qgl.h>
%End

public:
%If (Qt_4_2_0 -)

    enum OpenGLVersionFlag
    {
        OpenGL_Version_None,
        OpenGL_Version_1_1,
        OpenGL_Version_1_2,
        OpenGL_Version_1_3,
        OpenGL_Version_1_4,
        OpenGL_Version_1_5,
        OpenGL_Version_2_0,
        OpenGL_Version_2_1,
%If (Qt_4_5_0 -)
        OpenGL_Version_3_0,
%End
        OpenGL_ES_Common_Version_1_0,
        OpenGL_ES_CommonLite_Version_1_0,
        OpenGL_ES_Common_Version_1_1,
        OpenGL_ES_CommonLite_Version_1_1,
        OpenGL_ES_Version_2_0,
    };

%End
%If (Qt_4_2_0 -)
    typedef QFlags<QGLFormat::OpenGLVersionFlag> OpenGLVersionFlags;
%End
    QGLFormat();
    QGLFormat(QGL::FormatOptions, int plane = 0);
    QGLFormat(const QGLFormat &);
    ~QGLFormat();
    void setDepthBufferSize(int);
    int depthBufferSize() const;
    void setAccumBufferSize(int);
    int accumBufferSize() const;
    void setAlphaBufferSize(int);
    int alphaBufferSize() const;
    void setStencilBufferSize(int);
    int stencilBufferSize() const;
    void setSampleBuffers(bool);
    void setSamples(int);
    int samples() const;
    void setDoubleBuffer(bool);
    void setDepth(bool);
    void setRgba(bool);
    void setAlpha(bool);
    void setAccum(bool);
    void setStencil(bool);
    void setStereo(bool);
    void setDirectRendering(bool);
    void setOverlay(bool);
    int plane() const;
    void setPlane(int);
    void setOption(QGL::FormatOptions);
    bool testOption(QGL::FormatOptions) const;
    static QGLFormat defaultFormat();
    static void setDefaultFormat(const QGLFormat &);
    static QGLFormat defaultOverlayFormat();
    static void setDefaultOverlayFormat(const QGLFormat &);
    static bool hasOpenGL();
    static bool hasOpenGLOverlays();
    bool doubleBuffer() const;
    bool depth() const;
    bool rgba() const;
    bool alpha() const;
    bool accum() const;
    bool stencil() const;
    bool stereo() const;
    bool directRendering() const;
    bool hasOverlay() const;
    bool sampleBuffers() const;
%If (Qt_4_2_0 -)
    void setRedBufferSize(int);
%End
%If (Qt_4_2_0 -)
    int redBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setGreenBufferSize(int);
%End
%If (Qt_4_2_0 -)
    int greenBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setBlueBufferSize(int);
%End
%If (Qt_4_2_0 -)
    int blueBufferSize() const;
%End
%If (Qt_4_2_0 -)
    void setSwapInterval(int);
%End
%If (Qt_4_2_0 -)
    int swapInterval() const;
%End
%If (Qt_4_2_0 -)
    static QFlags<QGLFormat::OpenGLVersionFlag> openGLVersionFlags();
%End
};

bool operator==(const QGLFormat &, const QGLFormat &);
bool operator!=(const QGLFormat &, const QGLFormat &);

class QGLContext /Supertype=sip.wrapper/
{

%TypeHeaderCode
#include <qgl.h>
%End

public:
    QGLContext(const QGLFormat &, QPaintDevice *);
    virtual ~QGLContext();
    virtual bool create(const QGLContext *shareContext = 0);
    bool isValid() const;
    bool isSharing() const;
    void reset();
    QGLFormat format() const;
    QGLFormat requestedFormat() const;
    void setFormat(const QGLFormat &);
    virtual void makeCurrent();
    virtual void doneCurrent();
    virtual void swapBuffers() const;
    GLuint bindTexture(const QImage &, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QPixmap &, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
%If (Qt_4_4_0 -)
    void drawTexture(const QRectF &, GLuint, GLenum textureTarget = GL_TEXTURE_2D);
%End
%If (Qt_4_4_0 -)
    void drawTexture(const QPointF &, GLuint, GLenum textureTarget = GL_TEXTURE_2D);
%End
    GLuint bindTexture(const QString &);

protected:
%If (WS_X11)
%If (PyQt_NoOpenGLES)
    virtual void *chooseVisual();
%End
%End

public:
    void deleteTexture(GLuint);
    static void setTextureCacheLimit(int);
    static int textureCacheLimit();
    void *getProcAddress(const QString &) const;
    QPaintDevice *device() const;
    QColor overlayTransparentColor() const;
    static const QGLContext *currentContext();

protected:
    virtual bool chooseContext(const QGLContext *shareContext = 0);
    bool deviceIsPixmap() const;
    bool windowCreated() const;
    void setWindowCreated(bool);
    bool initialized() const;
    void setInitialized(bool);
    void generateFontDisplayLists(const QFont &, int);

public:
%If (Qt_4_6_0 -)
    static bool areSharing(const QGLContext *, const QGLContext *);
%End
%If (Qt_4_6_0 -)

    enum BindOption
    {
        NoBindOption,
        InvertedYBindOption,
        MipmapBindOption,
        PremultipliedAlphaBindOption,
        LinearFilteringBindOption,
        DefaultBindOption,
    };

%End
%If (Qt_4_6_0 -)
    typedef QFlags<QGLContext::BindOption> BindOptions;
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QImage &, GLenum, GLint, QFlags<QGLContext::BindOption>);
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QPixmap &, GLenum, GLint, QFlags<QGLContext::BindOption>);
%End

private:
    QGLContext(const QGLContext &);
};

class QGLWidget : QWidget
{

%TypeHeaderCode
#include <qgl.h>
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QGLWidget, &sipType_QGLWidget, -1, 1},
    #if QT_VERSION >= 0x040600
        {sipName_QGLShader, &sipType_QGLShader, -1, 2},
        {sipName_QGLShaderProgram, &sipType_QGLShaderProgram, -1, -1},
    #else
        {0, 0, -1, 2},
        {0, 0, -1, -1},
    #endif
    };
    
    int i = 0;
    
    sipType = 0;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
%If (- Qt_4_2_0)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(QGLContext * /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(QGLContext * /Transfer/, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
%If (- Qt_4_2_0)
    QGLWidget(const QGLFormat &, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WFlags flags = 0);
%End
%If (Qt_4_2_0 -)
    QGLWidget(const QGLFormat &, QWidget *parent /TransferThis/ = 0, const QGLWidget *shareWidget = 0, Qt::WindowFlags flags = 0);
%End
    virtual ~QGLWidget();
    void qglColor(const QColor &) const;
    void qglClearColor(const QColor &) const;
    bool isValid() const;
    bool isSharing() const;
    void makeCurrent();
    void doneCurrent();
    bool doubleBuffer() const;
    void swapBuffers();
    QGLFormat format() const;
    void setFormat(const QGLFormat &);
    const QGLContext *context() const;
    void setContext(QGLContext *, const QGLContext *shareContext = 0, bool deleteOldContext = true);
    QPixmap renderPixmap(int width = 0, int height = 0, bool useContext = false);
    QImage grabFrameBuffer(bool withAlpha = false);
    void makeOverlayCurrent();
    const QGLContext *overlayContext() const;
    static QImage convertToGLFormat(const QImage &);
    void setMouseTracking(bool);
    const QGLColormap &colormap() const;
    void setColormap(const QGLColormap &);
    void renderText(int, int, const QString &, const QFont &font = QFont(), int listBase = 2000);
    void renderText(double, double, double, const QString &, const QFont &font = QFont(), int listBase = 2000);
    virtual QPaintEngine *paintEngine() const;
    GLuint bindTexture(const QImage &, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QPixmap &, GLenum target = GL_TEXTURE_2D, GLint format = GL_RGBA);
    GLuint bindTexture(const QString &);
%If (Qt_4_4_0 -)
    void drawTexture(const QRectF &, GLuint, GLenum textureTarget = GL_TEXTURE_2D);
%End
%If (Qt_4_4_0 -)
    void drawTexture(const QPointF &, GLuint, GLenum textureTarget = GL_TEXTURE_2D);
%End
    void deleteTexture(GLuint);

public slots:
    virtual void updateGL();
    virtual void updateOverlayGL();

protected:
    virtual bool event(QEvent *);
    virtual void initializeGL();
    virtual void resizeGL(int, int);
    virtual void paintGL();
    virtual void initializeOverlayGL();
    virtual void resizeOverlayGL(int, int);
    virtual void paintOverlayGL();
    void setAutoBufferSwap(bool);
    bool autoBufferSwap() const;
    virtual void paintEvent(QPaintEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void glInit();
    virtual void glDraw();
    int fontDisplayListBase(const QFont &, int listBase = 2000);

public:
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QImage &, GLenum, GLint, QFlags<QGLContext::BindOption>);
%End
%If (Qt_4_6_0 -)
    GLuint bindTexture(const QPixmap &, GLenum, GLint, QFlags<QGLContext::BindOption>);
%End

private:
    QGLWidget(const QGLWidget &);
};

%If (Qt_4_2_0 -)
QFlags<QGLFormat::OpenGLVersionFlag> operator|(QGLFormat::OpenGLVersionFlag, QFlags<QGLFormat::OpenGLVersionFlag>);
%End
%If (Qt_4_6_0 -)
QFlags<QGLContext::BindOption> operator|(QGLContext::BindOption, QFlags<QGLContext::BindOption>);
%End
